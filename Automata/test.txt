
************ DFA

DFA
Q = [0,5)
S = { 0 }
F = { 3  4 }
Transitions = 
0->{ '0'->4  '1'->2 }
1->{ ['0','1']->2 }
2->{ '0'->4  '1'->2 }
3->{ '0'->2  '1'->3 }
4->{ ['0','1']->4 }

current = -1


DFA
Q = [0,5)
S = { 0 }
F = { 3  4 }
Transitions = 
0->{ '0'->4  '1'->2 }
1->{ ['0','1']->2 }
2->{ '0'->4  '1'->2 }
3->{ '0'->2  '1'->3 }
4->{ ['0','1']->4 }

current = -1

 is the DFA Usefulf ?: 1

The combination for all the out labels of State's£ºC = { '0'  '1' }
L:
0 1 2 3 4
0 0 0 0 0
Initialize partitions, E0:
StateEqRel
{ 0  1  2 }
{ 3  4 }

Initialize L repr = {F}:
{ 3 }
L:
0 1 2 3 4
0 0 0 2 0
=========================== Iterate: k = 1
L:
0 1 2 3 4
0 0 0 1 0
Partitions:
StateEqRel
{ 0  1  2 }
{ 3  4 }

pick [q] in L:([q],a)=([3],'1')
split [p] w.r.t. ([3],'1')
===split[0] w.r.t. ([3],'1')
new split of [0] is [-1]
===split[3] w.r.t. ([3],'1')
new split of [3] is [-1]
=========================== Iterate: k = 2
L:
0 1 2 3 4
0 0 0 0 0
Partitions:
StateEqRel
{ 0  1  2 }
{ 3  4 }

pick [q] in L:([q],a)=([3],'0')
split [p] w.r.t. ([3],'0')
===split[0] w.r.t. ([3],'0')
new split of [0] is [1]
[p]={ 0  2 }
[r]={ 1 }
p and r are the new representatives. Now update L with the smallest of [0] and [1]
using [r] = [1],L[r]=C.size();
after update L: 
L:
0 1 2 3 4
0 2 0 0 0
===split[3] w.r.t. ([3],'0')
new split of [3] is [4]
[p]={ 3 }
[r]={ 4 }
p and r are the new representatives. Now update L with the smallest of [3] and [4]
using [p] = [3],L[r]=L[p]; L[p]=C.size();
after update L: 
L:
0 1 2 3 4
0 2 0 2 0
=========================== Iterate: k = 3
L:
0 1 2 3 4
0 1 0 2 0
Partitions:
StateEqRel
{ 0  2 }
{ 1 }
{ 3 }
{ 4 }

pick [q] in L:([q],a)=([1],'1')
split [p] w.r.t. ([1],'1')
===split[0] w.r.t. ([1],'1')
new split of [0] is [-1]
===split[1] w.r.t. ([1],'1')
new split of [1] is [-1]
===split[3] w.r.t. ([1],'1')
new split of [3] is [-1]
===split[4] w.r.t. ([1],'1')
new split of [4] is [-1]
=========================== Iterate: k = 4
L:
0 1 2 3 4
0 0 0 2 0
Partitions:
StateEqRel
{ 0  2 }
{ 1 }
{ 3 }
{ 4 }

pick [q] in L:([q],a)=([1],'0')
split [p] w.r.t. ([1],'0')
===split[0] w.r.t. ([1],'0')
new split of [0] is [-1]
===split[1] w.r.t. ([1],'0')
new split of [1] is [-1]
===split[3] w.r.t. ([1],'0')
new split of [3] is [-1]
===split[4] w.r.t. ([1],'0')
new split of [4] is [-1]
=========================== Iterate: k = 5
L:
0 1 2 3 4
0 0 0 1 0
Partitions:
StateEqRel
{ 0  2 }
{ 1 }
{ 3 }
{ 4 }

pick [q] in L:([q],a)=([3],'1')
split [p] w.r.t. ([3],'1')
===split[0] w.r.t. ([3],'1')
new split of [0] is [-1]
===split[1] w.r.t. ([3],'1')
new split of [1] is [-1]
===split[3] w.r.t. ([3],'1')
new split of [3] is [-1]
===split[4] w.r.t. ([3],'1')
new split of [4] is [-1]
=========================== Iterate: k = 6
L:
0 1 2 3 4
0 0 0 0 0
Partitions:
StateEqRel
{ 0  2 }
{ 1 }
{ 3 }
{ 4 }

pick [q] in L:([q],a)=([3],'0')
split [p] w.r.t. ([3],'0')
===split[0] w.r.t. ([3],'0')
new split of [0] is [-1]
===split[1] w.r.t. ([3],'0')
new split of [1] is [-1]
===split[3] w.r.t. ([3],'0')
new split of [3] is [-1]
===split[4] w.r.t. ([3],'0')
new split of [4] is [-1]

************ minDFA

DFA
Q = [0,4)
S = { 0 }
F = { 2  3 }
Transitions = 
0->{ '0'->3  '1'->0 }
1->{ ['0','1']->0 }
2->{ '0'->0  '1'->2 }
3->{ ['0','1']->3 }

current = -1

