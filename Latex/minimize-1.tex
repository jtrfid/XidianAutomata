\chapter{Hopcroft's algorithm}

\subsection{algorithm}

Member function min\_Hopcroft implements Hopcroft's $n\log n$ minimization algorithm, as presented in [\cite{WATSON94b}, Algorithm 4.8].

\begin{algorithm}  
	\caption{Hopcroft's minimization algorithm}  \label{alg:hopcroft}
	\begin{algorithmic}[1] %每行显示行号  
		\Require $G =(Q,V,T,q_0,F)$  
		\Ensure The equivalence classes of $Q$  
		\State $P \gets [Q]_{E_0}=\{F,Q\setminus F \}$  \qquad\qquad $\triangleright$ The initial partitions is $[Q]_{E_0}$, it's the total euivalence relation.
		
		\State $L \gets 0$  \qquad\qquad $\triangleright$ The waiting set
		
		\ForAll {$a\in V$}
			\State $ADD((min(F,Q\setminus F),a),L)$ \qquad\qquad 			$\triangleright$ initialization of the waiting set
		\EndFor
		\While {$L\ne\emptyset$}
			\State $P_{old} = P;$
			\State $(Q_1,a)\gets TakeSome(L)$ \qquad\qquad $\triangleright$ Take and remove some splitter
			\State $L=L\setminus \{(Q_1,a)\};$
			\ForAll {$Q_0\in P_{old} $}
				\State $Q_0$ is split by $(Q_1,a)$  \qquad\qquad $\triangleright$ Compute the split, $Q_0$ is splitted into $Q_0^\prime$ and $Q_0^{\prime\prime}$
				\State $Q_0^{\prime}=\{p|p\in Q_0\land T(p,a)\in Q_1\}$ 
				\State $Q_0^{\prime\prime}=\{Q_0\setminus Q_0^\prime\}$
				\State $P=P\setminus \{Q_0\}\cup\{Q_0^\prime, Q_0^{\prime\prime}\}$ \qquad\qquad $\triangleright$ Refine the partition, Replace $Q_0$ by $Q_0^\prime$ and $Q_0^{\prime\prime}$ in $P$.
			
				\ForAll {$b\in V$}  \qquad\qquad $\triangleright$ Update the waiting set
					\If {$(Q_0,b)\in L$}
						\State $L=L\setminus \{(Q_0,b)\}\cup\{(Q_0^\prime,b),(Q_0^{\prime\prime},b)\} $ \qquad\qquad $\triangleright$ Replace $(Q_0, b)$ by $(Q_0^\prime, b)$ and $(Q_0^{\prime\prime}, b)$ in $L$
					\Else
						\State $ADD((min(Q^\prime,Q^{\prime\prime}),b),L)$
						\EndIf  
				\EndFor
			\EndFor 
		\EndWhile
	\end{algorithmic}
\end{algorithm}

The combination of the out-transitions of all of the States is stored in a
\textbf{CRSet $C$}. 

Set \text{$L$} from the abstract algorithm is implemented as a mapping from States to int (an array of int is used). 

Array $L$ should be interpreted as follows: if State q a representative,
then the following pairs still require processing (are still in abstract set L):
$$([q], C_0),\cdots, ([q], C_{L(q)-1}) $$

The remaining pairs do not require processing:
$$([q], C_{L[q])}),\cdots, ([q], C_{|C|-1}) $$

This implementation facilitates quick scanning of $L$ for the next valid State-CharRange pair.

\begin{algorithm}  
	\caption{Hopcroft's minimization algorithm}  \label{alg:hopcroft}
	\begin{algorithmic}[1] %每行显示行号  
		\Require $G =(Q,V,T,q_0,F)$  
		\Ensure The equivalence classes of $Q$  
		\State $P \gets [Q]_{E_0}=\{F,Q\setminus F \}$  \qquad\qquad $\triangleright$ The initial partitions is $[Q]_{E_0}$, it's the total euivalence relation.
		
		\State $L \gets 0$  \qquad\qquad $\triangleright$ The waiting set
		\State $C = V$  \qquad\qquad $\triangleright$ C is all symbols set
		
		\If {$|F|\le |Q\setminus F|$}  \qquad\qquad 			$\triangleright$ initialization of the waiting set
			\State $L[q]=C.Size(), [q]$ is the representive of the $F$
		\Else
			\State $L[q]=C.Size(), [q]$ is the representive of the $Q\setminus F$
		\EndIf
		
		\While {(1)}
			\If {all L[q]=0 } 
				\State break;
			\EndIf
			
			\State Find the first pair in L that still needs processing. $(Q_1,a) = [q], L[q]\ne 0$ \qquad\qquad $\triangleright$ Take and remove some splitter
			
			\State $P_{old} = P$  \qquad\qquad $\triangleright$ current partitions
			
			\State $L[q]--$; \qquad\qquad $\triangleright$ Mark this element of L as processed.
	
			\ForAll {$Q_0\in P_{old} $}
				\State $Q_0$ is split by $(Q_1,a)$  \qquad\qquad $\triangleright$ Compute the split, $Q_0$ is splitted into $Q_0^\prime$ and $Q_0^{\prime\prime}$
				\State $Q_0^{\prime}=\{p|p\in Q_0\land T(p,a)\in Q_1\}$ 
				\State $Q_0^{\prime\prime}=\{Q_0\setminus Q_0^\prime\}$
				\State $P=P\setminus \{Q_0\}\cup\{Q_0^\prime, Q_0^{\prime\prime}\}$ \qquad\qquad $\triangleright$ Refine the partition, Replace $Q_0$ by $Q_0^\prime$ and $Q_0^{\prime\prime}$ in $P$.
				\State $p=Q_0$
				\State $r=Q_0^\prime$
				\If {$[r] != Invalid$}  \qquad\qquad $\triangleright$ Update the waiting set
					\If {($ [p]\le |[r]|$)}
					\State $L[r]=L[p] $ \qquad\qquad $\triangleright$  [r]待处理L[p]剩下的字符
					\State $L[p]=C.size()$  \qquad\qquad $\triangleright$  新的[p], 待处理C[0]...C[C.size()-1]
					\Else
					\State $L[r]=C.size() $ \qquad\qquad $\triangleright$ // 新的[r]，待处理C[0]...C[C.size()-1]
					\EndIf  
				\EndIf 
			\EndFor
		\EndWhile
	\end{algorithmic}
\end{algorithm}

\subsection{Example}

\begin{figure} \centering 
	\subfigure[DFA] { \label{fig:a1} 
		\includegraphics[width=0.4\columnwidth] {NOSINK} 
	} 
	\subfigure[mini-DFA] { \label{fig:b2} 
		\includegraphics[width=0.4\columnwidth] {MNOSINK} 
	} 
	\caption{ example minimization } 
	\label{fig:mini-ex} 
\end{figure}



CRSet C;  // the out labels of State's：{ 'a'  'b' } 

int L10]: // the index of L = q: 对应等价类[q]; L[q]表示正在处理等价类[q]的字符在C中的index。$L = \{ 0,0,0,0,0,0,0,0,0 \} $

Initialize P to be the total equivalence relation $E_0=\{Q\setminus F, F\}$: $P = \{ \{ 0,1,2,3,4,5 \}, \{6,7,8 \} \}$;

$F.size <= (Q.size() - F.size()$

$L = \{ 0,0,0,0,0,0,2,0,0 \} $ // L[6] represented eq. class in $P$


--- while each [q], (split [p] w.r.t ([q],a))

$[q] = [6]$ // Pick one [q] in L, Processing [6] in current partitions \{ 6,7,8 \}

=== for each [p], (split [p] w.r.t [6],'b')

===split [0] w.r.t [6],'b')

before split, partitions: \{ 0  1  2  3  4  5 \},\{ 6  7  8 \} 

new split of [0] is [1]

after split, partitions: \{ 0  2  3  4  5 \}, \{ 1 \},\{ 6  7  8 \}

before L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 1 0 0

p and r are the new representatives. Now update L with the smallest of [0],[1]
using [r] = [1],L[r]=C.size();

affter L:
0 1 2 3 4 5 6 7 8
0 2 0 0 0 0 1 0 0

===split[6] w.r.t (index of L)[6],'b')
before split, partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7  8 }

new split of [6] is [8]
after split, partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

before L:
0 1 2 3 4 5 6 7 8
0 2 0 0 0 0 1 0 0

p and r are the new representatives. Now update L with the smallest of [6],[8]
using [r] = [8],L[r]=C.size();

affter L:
0 1 2 3 4 5 6 7 8
0 2 0 0 0 0 1 0 2

--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 2 0 0 0 0 1 0 2
Pick one [q] in L, Processing [q]= index of L = [1]，'b'
current all partitions(eq.classes) repr:
{ 0  1  6  8 }
current all partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[1],'b')
===split[0] w.r.t (index of L)[1],'b')
before split, partitions:
StateEqRel
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[1],'b')
before split, partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[6] w.r.t (index of L)[1],'b')
before split, partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[1],'b')
before split, partitions:
StateEqRel
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 1 0 0 0 0 1 0 2
Pick one [q] in L, Processing [q]= index of L = [1]，'a'
current all partitions(eq.classes) repr:
{ 0  1  6  8 }
current all partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[1],'a')
===split[0] w.r.t (index of L)[1],'a')
before split, partitions:
{ 0  2  3  4  5 }
{ 1 }
{ 6  7 }
{ 8 }

new split of [0] is [2]
after split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

before L:
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 1 0 2
p and r are the new representatives. Now update L with the smallest of [0],[2]
using [p] = [0],L[r]=L[p]; L[p]=C.size();
affter L:
L:
0 1 2 3 4 5 6 7 8
2 0 0 0 0 0 1 0 2
===split[1] w.r.t (index of L)[1],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[6] w.r.t (index of L)[1],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[1],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
2 0 0 0 0 0 1 0 2
Pick one [q] in L, Processing [q]= index of L = [0]，'b'
current all partitions(eq.classes) repr:
{ 0  1  2  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[0],'b')
===split[0] w.r.t (index of L)[0],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[0],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[0],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [-1]
===split[6] w.r.t (index of L)[0],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[0],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
1 0 0 0 0 0 1 0 2
Pick one [q] in L, Processing [q]= index of L = [0]，'a'
current all partitions(eq.classes) repr:
{ 0  1  2  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[0],'a')
===split[0] w.r.t (index of L)[0],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[0],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[0],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [-1]
===split[6] w.r.t (index of L)[0],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[0],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 1 0 2
Pick one [q] in L, Processing [q]= index of L = [6]，'a'
current all partitions(eq.classes) repr:
{ 0  1  2  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[6],'a')
===split[0] w.r.t (index of L)[6],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[6],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[6],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3  4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [4]
after split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

before L:
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 0 0 2
p and r are the new representatives. Now update L with the smallest of [2],[4]
using [p] = [2],L[r]=L[p]; L[p]=C.size();
affter L:
L:
0 1 2 3 4 5 6 7 8
0 0 2 0 0 0 0 0 2
===split[6] w.r.t (index of L)[6],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[6],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 2 0 0 0 0 0 2
Pick one [q] in L, Processing [q]= index of L = [2]，'b'
current all partitions(eq.classes) repr:
{ 0  1  2  4  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[2],'b')
===split[0] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [-1]
===split[4] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [4] is [-1]
===split[6] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 1 0 0 0 0 0 2
Pick one [q] in L, Processing [q]= index of L = [2]，'a'
current all partitions(eq.classes) repr:
{ 0  1  2  4  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[2],'a')
===split[0] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2  3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [3]
after split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

before L:
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 0 0 2
p and r are the new representatives. Now update L with the smallest of [2],[3]
using [p] = [2],L[r]=L[p]; L[p]=C.size();
affter L:
L:
0 1 2 3 4 5 6 7 8
0 0 2 0 0 0 0 0 2
胡
===split[4] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [4] is [-1]
===split[6] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[2],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 1 0 0 0 0 0 2
Pick one [q] in L, Processing [q]= index of L = [2]，'a'
current all partitions(eq.classes) repr:
{ 0  1  2  3  4  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[2],'a')
===split[0] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [-1]
===split[3] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [3] is [-1]
===split[4] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [4] is [-1]
===split[6] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[2],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 0 0 2
Pick one [q] in L, Processing [q]= index of L = [8]，'b'
current all partitions(eq.classes) repr:
{ 0  1  2  3  4  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[8],'b')
===split[0] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [-1]
===split[3] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [3] is [-1]
===split[4] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [4] is [-1]
===split[6] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[8],'b')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 0 0 1
Pick one [q] in L, Processing [q]= index of L = [8]，'a'
current all partitions(eq.classes) repr:
{ 0  1  2  3  4  6  8 }
current all partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

=== for each [p], (split [p] w.r.t (index of L)[8],'a')
===split[0] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [0] is [-1]
===split[1] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [1] is [-1]
===split[2] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [2] is [-1]
===split[3] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [3] is [-1]
===split[4] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [4] is [-1]
===split[6] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [6] is [-1]
===split[8] w.r.t (index of L)[8],'a')
before split, partitions:
StateEqRel
{ 0 }
{ 1 }
{ 2 }
{ 3 }
{ 4  5 }
{ 6  7 }
{ 8 }

new split of [8] is [-1]
--- while each [q], (split [p] w.r.t ([index of L]=[q],a))
L:
0 1 2 3 4 5 6 7 8
0 0 0 0 0 0 0 0 0
%\end{lstlisting}

\section{Minimization by equivalence of states}



\begin{figure}[htbp]
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm, semithick]
	\tikzstyle{every state}=[minimum size=0.1mm]
	\node[initial,state] (p1)  {$1$};
	\node[state]         (p2) [right of=p1] {$2$};
	\node[state]         (p3) [right of=p2] {$3$};
	\node[state]         (p4) [right of=p3] {$4$};
	\node[state]         (p5) [right of=p4] {$5$};
	\node[state,accepting] (p6) [right of=p5] {$6$};
	\path
	(p1) edge [loop above] node {1} (p1)
	     edge [] node {0} (p2)
	(p2) edge [loop above] node {1} (p2)
	     edge [] node {0} (p3)
	(p3) edge [loop above] node {1} (p3)
		 edge [] node {0} (p4)
    (p4) edge [loop above] node {1} (p4)
         edge [] node {0} (p5)
    (p5) edge [loop above] node {1} (p5)
         edge [] node {0} (p6)
    (p6) edge [loop above] node {0,1} (p6)
	;
	\end{tikzpicture}
	\caption{Minimizing example} \label{fig:mini-ex1}
\end{figure}



\begin{figure} [htbp]
	\{a,b\},\{d,e\}is not equivalent states. \\
	Sets of equivalent states: \{a,c\},\{b\},\{d\},\{e\}\\
	%\includegraphics[scale=0.4] {mini-fa} 
	\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.5cm, semithick]
	\tikzstyle{every state}=[minimum size=0.1mm]
	\node[state] (a) {$a$};
	\node[state,accepting] (d) [right of=a] {$d$};
	\node[state] (c) [below of=a] {$c$};
	\node[state] (b) [left of=c] {$b$};
	\node[state,accepting] (e) [right of=c] {$e$};
	\path
	(d) edge [loop above] node {$0,1$} (d)
	(c) edge [loop below] node {$1$} (c)
	(e) edge [loop below] node {$1$} (e)
	(a) edge [] node {$0$} (d)
	(a) edge [swap] node {$1$} (c)
	(b) edge [swap] node {$0,1$} (c)
	(e) edge [] node {$0$} (c)
	(c) edge [] node {$0$} (d)
	;
	\end{tikzpicture}
	\caption{Finite state automaton}
	\label{fig:mini-ex2}
\end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}
		\bibitem[Hopcroft2008]{Hopcroft2008}
	John E. Hopcroft,Rajeev Motwani,Jeffrey D. Ullman著,孙家骕等译,\textit{自动机理论、语言和计算机导论},Third Edition, 机械工业出版社,2008.7
	
	\bibitem[WATSON93a]{WATSON93a}
	WATSON, B. W. \textit{A taxonomy of finite automata construction algorithms}, Computing Science Note 93/43, Eindhoven University of Technology, The Netherlands, 1993. Available by ftp from ftp.win.tue.nl in pub/techreports/pi.
	
	\bibitem[WATSON93b]{WATSON93b}
	WATSON, B. W. \textit{A taxonomy of finite automata minimization algorithms}, Computing Science Note 93/44, Eindhoven University of Technology, The Netherlands, 1993. Available by ftp from ftp.win.tue.nl in pub/techreports/pi.
	
	\bibitem[WATSON94a]{WATSON94a}
	WATSON, B. W. \textit{An introduction to the FIRE engine: A C++ toolkit for FInite automata and Regular Expressions}, Computing Science Note 94/21, Eindhoven University of Technology, The Netherlands, 1994. Available by ftp from ftp.win.tue.nl in pub/techreports/pi
	
	\bibitem[WATSON94b]{WATSON94b}
	WATSON, B.W. \textit{The design. and implementation of the FIRE engine:	A C++ toolkit for FInite automata and Regular Expressions}, Computing Science Note 94/22, Eindhoven University of Technology, The Netherlands, 1994. Available by ftp from ftp.win.tue.nl in pub/techreports/pi.
	
	\bibitem[Chrison2007]{Chrison2007}
	Christos G. Cassandras and St$\acute{e}$phane Lafortune, \textit{Introduction to Discrete Event Systems},Second Edition,New York,Springer,2007
	
	\bibitem[Wonham2018]{Wonham2018}
	W. M. Wonham and Kai Cai,\textit{Supervisory Control of Discrete-Event Systems}, Revised 2018.01.01
	
	\bibitem[Jean2018]{Jean2018}
	Jean-$\acute{E}$ric Pin, \textit{Mathematical Foundations of Automata Theory},Version of June 15,2018
	
	\bibitem[蒋宗礼2013]{蒋宗礼2013}
	蒋宗礼,姜守旭, \textit{形式语言与自动机理论（第3 版）}, 清华大学出版社,2013.05
	
	
	\bibitem[Lipschutz2007]{Lipschutz2007}
	S. Lipschutz and M. L. Lipson, \textit{Schaum's Outline of Theory and Problems of Discrete Mathematics}, Third Edition, New York: McGraw-Hill, 2007.
	
	\bibitem[Rosen2007]{Rosen2007}
	K. H. Rosen, \textit{Discrete Mathematics and Its Applications}, Seventh Edition, New York: McGraw-Hill, 2007.
	
	\bibitem[R.Su and Wonham2004]{R.Su and Wonham2004}
	R. Su and W. M. Wonham, \textit{Supervisor reduction for discrete-event systems}, Discrete Event Dyn. Syst., vol. 14, no. 1, pp. 31–53, Jan. 2004.
	
	\bibitem[Hopcroft71]{Hopcroft71}
	Hopcroft, J.E. \textit{An n log n algorithm for minimizing states in a finite automaton}, in The Theory of Machines and Computations (Z. Kohavi, ed.), pp.180-196, Academic Press, New York, 1971.
	
	\bibitem[Gries73]{Gries73}
	Gries, D. \textit{Describing an Algorithm by Hopcroft}, Acta Inf. 2:97 109, 173. $\copyright$ by Springer-Verlag 1973
	
	\bibitem[Knuutila2001]{Knuutila2001}
	Knuutila, T. \textit{Re-describing an Algorithm by Hopcroft}. Theoret. Computer Science 250 (2001) 333--363.
	
	\bibitem[Ratnesh95]{Ratnesh95}
	Ratnesh Kumar, \textit{Modeling and Control of Logical Discrete Event Systems}, $\copyright$ 1995 by Springer Science+Business Media New York.
	
	\bibitem[Jean2011]{Jean2011}
	Jean Berstel, Luc Boasson, Olivier Carton, Isabelle Fagnot
	, \textit{Minimization of automata}, Universit$\acute{e}$ Paris-Est Marne-la-Vall$\acute{e}$e 2010 Mathematics Subject Classification: 68Q45, 2011.
	
	\bibitem[Kenneth2012]{Kenneth2012}
	Kenneth H. Rosen著,徐六通译, \textit{离散数学及其应用Discrete Mathematics and Its Applications},seventh Edition, 2012, 机械工业出版社, 北京, 2014.
	
\end{thebibliography}
