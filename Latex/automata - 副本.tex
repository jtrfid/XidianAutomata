\chapter{automata abstract}

$\emph{P}$ $\texttt{P}$ $\P$  $\mathrm{P}$  $\mathcal{P}$ $\mathit{P}$  $\mathnormal{P}$  $\boldsymbol{P}$  $\mathbf{P}$

\hfill

\section*{}
\cite[p6]{WATSON93a} $\textbf{the signatures of the transition relations:}$

$T \in \mathbb{P}(Q \times V \times Q)$

$T \in V \to P(Q \times Q)$

$T \in Q\times Q \to P(V)$

$T \in Q \times V \to P(Q)$

$T \in Q \to P(V \times Q)$

for example, the function $T \in Q \to P(V \times Q)$ is defined as $T(p) = \{(a,q):(p,a,q) \in T\}$

\hfill

$\textbf{$\epsilon$-transition relation:}$

$E \in P(Q\times Q)$

$E \in Q \to P(Q)$

\hfill

$T \in P(Q \times V \times Q), T = \{(s,a,q) \}$

$T(s)\in Q \to P(V\times Q), T(s) = \{(a,q):(s,a,q) \in T\}$

$Q_{map}: P(Q\times V), Q_{map} = \{(q,a): (s,a,q) \in T\}$

$Q_{map}(q) = \{a: (s,a,q)\in T\}$

${Q_{map}}^{-1}: V \nrightarrow P(Q), {Q_{map}}^{-1} = \{(a,q): (s,a,q) \in T\}$

According to \cite[Convention A.4]{WATSON93a} (Tuple projection):

$\bar{\pi}_2(T) = \{(s,q): (s,a,q)\in T \}$

$Q_{map} = (\bar{\pi}_1(T))^R, Q_{map} = \{(a,q):(s,a,q) \in T\}^R = \{(q,a):(s,a,q) \in T\}$

\hfill

$f(a)=(f(a^R))^R$

\hfill

\begin{definition}[Prefix-closure\cite{Chrison2007}]
	Let $L\subseteq V^*$,then
	$$\overline{L} := \{s\in V^*:(\exists t\in V^*)[st\in L]\}$$
\end{definition}
In words, the prefix closure of L is the language denoted by $\overline{L}$ and consisting of all the prefixes in L. In general, $L\subseteq \overline{L}$.

L is said to be prefix-closed if $L = \overline{L}$. Thus language L is prefix-closed if any prefix of any string in L is also an element of L.

$L_1 = \{\epsilon,a,aa\}, L_1 = \overline{L_1}, L_{1}$ is prefix-closed.

$L_2 = \{a,b,ab\}, \overline{L_2} = \{\epsilon,a,b,ab\}, L_2 \subset \overline{L_2}, L_2$ is not prefix closed.

\hfill

\begin{definition}[Post-closure\cite{Chrison2007}]
Let $L\subseteq V^{\ast}$ and $s\in L$. Then the post-language of L after s, denoted by L/s, is the language
$$ L/s := \{t\in V^{\ast}:st\in L\}$$
By definition, $L/s = \emptyset$ if $s \notin \overline{L}$.
\end{definition}

\hfill

\begin{definition}[Left derivatives\cite{WATSON93a}] Given language $A\subseteq V^{\ast}$ and $w\in V^{\ast}$ we define the left derivative of A with respect to $w$ as:
$$w^{-1}A = \{x\in V^{\ast}:wx\in A\}$$
$A$关于$w$的左导数，就是$A$中： \{$w$的后缀组成的字符串集合\}。

Sometimes derivatives are written as $D_{w}A$ or as $\frac{dA}{dw}$. Right derivatives are analogously defined. Derivatives can also be extended to $B^{-1}A$ where B is also a language.
\end{definition}

\begin{example}
$A = \{a,aab,baa\},a^{-1}A = D_{a}A = \frac{dA}{da} =\{\epsilon,ab,\emptyset\} = \{\epsilon,ab\}$ \hfill$\square$ 
\end{example}

\begin{example}
	$L = \{ba,baa,baab,ca\}, w = \{ba\},$
	
	$w^{-1}L =\{\epsilon,a,ab,\emptyset\} = \{\epsilon,a,ab\}$
	
	${(wa)}^{-1}L = {(baa)}^{-1}L = \{\emptyset,\epsilon,b,\emptyset\} = \{\epsilon,b\}$
	
	$a^{-1}(w^{-1}L) = a^{-1}\{\epsilon,a,ab\} = \{\emptyset,\epsilon,b\} = \{\epsilon,b\}$
	
	$w\in L \equiv \epsilon \in w^{-1}L,and {(wa)}^{-1}L = a^{-1}(w^{-1}L)$ \hfill$\square$ 
\end{example}

\begin{example}
	$a^{-1}\{a\} = \{\epsilon\}; \quad a^{-1}\{b\} = \emptyset,\quad\Leftarrow if (a\ne b)$ \hfill$\square$ 
\end{example}

\begin{example}
	$L_0 = \{ab\},L_1 = \{ac\}, L_0L_1 = \{abac\}$
	
	$a^{-1}(L_0L_1) = \{bac\}$
	
	$a^{-1}(L_0L_1) = (a^{-1}L_0)L_1 \cup \emptyset \quad \Leftarrow(\epsilon \notin L_0)$
	
	$= \{b\}L_1 = \{bac\}$ \hfill$\square$ 
\end{example}

\begin{example}
	$L_0 = \{\epsilon,ab\},L_1 = \{ac\}, L_0L_1 = \{ac,abac\}$
	
	$a^{-1}(L_0L_1) = \{c,bac\}$
	
	$a^{-1}(L_0L_1) = (a^{-1}L_0)L_1 \cup a^{-1}L_1 \quad\Leftarrow(\epsilon \in L_0)$
	
	$= \{\emptyset,b\}L_1 \cup \{c\} = \{c,bac\}$ \hfill$\square$ 
\end{example}

\begin{proof}
	$a^{-1}(L_0L_1)$
	
	$1. if(\epsilon \in L_0) \Rightarrow a^{-1}(L_0L_1) = (a^{-1}L_0)L_1 \cup a^{-1}L_1 $ 
	
	$L_0 = (L_0 \backslash \{\epsilon\}) \cup \{\epsilon\}$
	
	$a^{-1}(L_0L_1) = a^{-1}(((L_0 \backslash \{\epsilon\}) \cup \{\epsilon\})L_1)$
	
	$=a^{-1}(L_0L_1\cup L_1)$
	
	$a^{-1}L_0 = a^{-1}((L_0 \backslash \{\epsilon\}) \cup \{\epsilon\})$
	
	$=a^{-1}(L_0\ \backslash \{\epsilon \}) \cup a^{-1}\{\epsilon \}$
	
	$=a^{-1}L_0 \cup \emptyset = a^{-1}L_0$
\end{proof}
	

\clearpage

From \cite[p99]{Hopcroft2008}

(1)如果$L$是一个语言，$a$是一个符号，则$L/a$(称作$L$和$a$的商)是所有满足如下条件的串$w$的集合：$wa$属于$L$。
例如，如果$L=\{a,aab,baa\}$,则$L/a = \{\epsilon,ba\}$, 证明：如果$L$是正则的，那么$L/a$也是。提示：从$L$的$DFA$出发，考虑接受状态的集合。

(2)如果$L$是一个语言，$a$是一个符号，则$a\backslash L$是所有满足如下条件的串$w$的集合: $aw$属于$L$。例如，如果$L=\{a,aab,baa\}$,则$a\backslash L=\{\epsilon,ab\}$,证明：如果$L$是正则的，那么$a\backslash L$也是。提示：记得正则语言在反转运算下是封闭的，又由(1)知，正则语言的商运算下是封闭的。

\begin{definition}[Kleene-closure\cite{Chrison2007}]
	Let $L\subseteq V^{\ast}$, then 
	$$L^{\ast} := \{\epsilon\}\cup L \cup LL\cup LLL\cup \cdots$$ 
\end{definition}

This is the same operation that we defined above for the set V, except that now it is applied to set L whose elements may be strings of length greater than one. An element of $L^*$ is formed by the concatenation of a finite (but possibly arbitrarily large) number of elements of L; this includes the concatenation of "zero" elements, that is the empty string $\epsilon$. Note that $\ast$ operation is idempotent: ${(L^*)}^* = L^*$.
\begin{align*}
L^{\ast} &= \{\epsilon\} +L^{+} \\
&=  \{\epsilon\}\cup (L\backslash \{\epsilon\})L^{\ast}\\ &=\{\epsilon\} + L + LL + LLL + \cdots 
\end{align*}

\section{Linear equation}

see \cite[5.3,p64]{Jean2018}.

We give an algorithm to covert an automaton to a rational(regular) expression. The algorithm amounts to solving a system of linear equations on languages. We first consider an equation of the form
\begin{equation}\label{Linear equation}
X = KX + L
\end{equation}

\begin{proposition}[Arden's Lemma]
	if $K$ does not contain the empty word, then $X = K^\star L$ is the unique solution of the equation $X = KX + L$.
\end{proposition}
where $K$ and $L$ are languages and $X$ is the unknown. When $K$ does not contain the empty word, the equation admits a unique solution.

\begin{proof}
	Replacing $X$ by $K^{\ast}L$ in the expression $KX+L$,one gets
	$$K(K^{\ast})L + L = K^{+}L + L = (K^{+}L + L) = K^{\ast}L,$$
	and hence $X = K^{\ast}L$ is a solution of (\ref{Linear equation}). see\footnote[1]{\begin{align*}
		K^{\ast} &= \{\epsilon\} + K^{+} \\
		&=  \{\epsilon\} + (K\backslash \{\epsilon\})K^{\ast}\\ &=\{\epsilon\} + K + KK + KKK + \cdots 
		\end{align*}}\label{star}
	
	To Prove uniqueness, consider two solutions $X_{1}$ and $X_{2}$ of (\ref{Linear equation}). By symmetry,it suffices to show that each word $u$ of $X_1$ also belongs to $X_2$. Let us prove this result by induction on the length of $u$.
	
	If $|u| = 0$, $u$ is the empty word\footnote[2]{The empty word = $\epsilon,|\epsilon| = 0$; if a language $M = \{\epsilon\}, |M| = 1$, The empty language $M = \emptyset, |M| = 0$. 文献\cite{Jean2018}用1表示$\epsilon$,因为$\epsilon K = K\epsilon = K$, 因此,$\epsilon$是连接运算的单位元，正是1表示的用意。0表示$\emptyset$,它是并运算的单位元,$K\cup \emptyset = \emptyset \cup K = K$.} and if $u \in X_1 = KX_1 + L$, then necessarily $u\in L$ since $\epsilon \notin K$. But in this case, $u\in KX_2 + L = X_2$. see\footnote[3]{In this case,$|u| = 0, X = \{\epsilon\},|X| = 1.\quad i.e.\quad\epsilon = K\epsilon + L, \epsilon = K + L$}
	
	For the induction step, consider a word $u$ of $X_1$ of length $n + 1$. Since $X_1 = KX_1 + L, u$ belongs either to $L$ or to $KX_1$. if $u\in L$, then $u\in KX_2 + L = X_2$. If $u\in KX_1$ then $u = kx$ for some $k\in K$ and $x\in X_1$. Since $k$ is not the empty word, one has necessarily $|x| \leq n$ and hence by induction $x\in X_2$.[see\footnote[4]{$u = kx,|u|=|kx|=n+1,\epsilon \notin K,|k|\ge 1,|x|\le n$,由假设知，$u$属于$X_1$,归纳$|x|=0,|x|=1,\cdots,n,x\in X_2$.}] It follows that $u\in KX_2$ and finally $u\in X_2$. This conclude the induction and the proof of the proposition.  \hfill$\square$ 
\end{proof}

\begin{svgraybox}
	
From \cite[p74]{Wonham2018} 
The \textit{length} $|s|$ of a string $s\in \Sigma^{\ast}$ is defined according to
$$|\epsilon| = 0; |s| = k, \text{if }s = \sigma_1\sigma_2 \cdots\sigma_k\in \Sigma ^{+}$$
Thus $|cat(s,t)| = |s| + |t|$.

A \textit{language} over $\Sigma$ is any subset of $\Sigma^{\ast}$, i.e. an element of the power set $Pwr(\Sigma^{\ast})$; thus the definition includes both the empty language $\emptyset$, and $\Sigma^{\ast}$ itself.

Note the distinction between $\emptyset$ (the language with no strings) and $\epsilon$ (the string with no symbols). For instance the language $\{\epsilon\}$ is nonempty, but contains only the empty string.
\end{svgraybox}	

From \cite[p78]{Wonham2018}
\begin{proposition}[\cite{Wonham2018}]
	\begin{enumerate}
		\item If $L = M^{\ast}N$ then $L = ML + N$
		\item If $\epsilon\notin M$ then $L = ML + N$ implies $L = M^{\ast}N$ \hfill$\square$ 
	\end{enumerate}
\end{proposition}
Part(2) is Known as Arden's rule. Taken with Part(1) it says that if $\epsilon\notin M$ then $L = M^{\ast}N$ is the unique solution of $L = ML + N$; in particular if $L = ML$ (with $\epsilon \notin M$) then $L = \emptyset$

\begin{exercise}
	Show by counterexample that the restriction $\epsilon \notin M$ in Arden's rule cannot be dropped.
\end{exercise}
\begin{solution}
	Examples text goes here.  
\end{solution}

\begin{exercise}
	Prove Arden's rule. Hint: If $L = ML + N$ then for every $k\geq 0$
	$$L = M^{k+1}L + (M^{k} + M^{k-1} + \cdots + M + \epsilon)N$$
\end{exercise}

\begin{solution}
	\begin{align*} Preliminaries:\\
		M^{\ast} &= M^{k} + M^{k-1} + \cdots + M^{1} + M^{0} \qquad (k\geq 0)\\
		         &= M^{k} + M^{k-1} + \cdots + M^{1} + \epsilon \\ 
		         &= M^{+} + \epsilon\\
		         &= MM^{*} + \epsilon\\
		         &= (M\backslash\{\epsilon\})M^{*} + \epsilon\\
		M^{+} &= M^{k} + M^{k-1} + \cdots + M^{1} \qquad (k > 0)\\
		      &= M(M^{k} + M^{k-1} + \cdots + M^{1} + M^{0}) \\ 
		      &= MM^{*}\\
	    M^{0} &= \{\epsilon\} = 1\\
	    M\epsilon &= \epsilon M = M\\
	    \epsilon+\epsilon &=\epsilon\\
	    M+M &= M
	\end{align*}
	\begin{proof}
		$$L = ML + N \Rightarrow$$  
		\begin{align}
			M^0L &= M^1L + M^0N \\
			M^1L &= M^2L + M^1N \\ 
			M^2L &= M^3L + M^2N \\ 
		\end{align}
		$$\cdots$$
		$\Rightarrow\\ (M^0+M^1+M^2+\cdots)L = (M^1+M^2+M^3+\cdots)L + (M^0+M^1+M^2+\cdots)N \\ \Rightarrow$ 
	    
	    so,if $L = ML +N$,then for every $k \ge 0$
	    
		$L = M^{k+1}L + (M^k+M^{k-1}+\cdots+M+M^0)N \\ \Rightarrow$
		
		\begin{equation}\label{leq}
			L = M^{k+1}L + (M^k+M^{k-1}+\cdots+M+\epsilon)N
		\end{equation}
		
		(1) $k = 0$\\
		$L = ML + (\epsilon)N = ML + N \\ \Rightarrow 
		(1-M)L = N \\
		(\epsilon-M)L = N$\\
		由于$\epsilon \notin M$,左端不会消去\{$\epsilon$\}.因此,只能在$N$中找$L$,仅有唯一解: $L
		=\{\epsilon\} = \text{\{empty word\}} \subseteq N$.  

	\end{proof}
%	Replacing L by $M^{\ast}N$ in the expression $ML + N$, one gets
%	\begin{align*}
%	     $L = ML + N$
%	\end{align*}
%	and hence $L = M^{*}N$ is a solution of $L = ML + N$. 
%	
%	To Prove uniqueness, consider two solutions $L_{1}$ and $L_{2}$ of $ML + N$. By symmetry,it suffices to show that each string $s$ of $L_1$ also belongs to $L_2$. Let us prove this result by induction on the length of $s$.
%	
%	if $|s| = 0$, $s$ is the empty string($\epsilon$) and if $s\in L_1 = ML_1 + N$, then necessarily $s\in N$ since $\epsilon\notin M$. But in this case, $s\in ML_2 + N = L_2$. see\footnote[1]{In this case,$|s| = 0, L = \{\epsilon\},|L| = 1.\quad i.e.\quad\epsilon = M\epsilon + N,  \epsilon = M + N$}
%	
%	Replacing L by $M^{\ast}N$ in the expression $ML + N$, one gets
%	\begin{align*}
%	L = M(M^{\ast}N) + N &= M((M^{k} + M^{k-1} + \cdots + M^{1} + M^{0})N) + N \qquad (k\geq 0)\\
%	&= \text{(by associative law)} \\ 
%	&= (M(M^{k} + M^{k-1} + \cdots + M^{1} + M^{0}))N + N \\
%	&= \text{(by distributive law)} \\ 
%	&= (M^{k+1} + M^{k} + M^{k-1} + \cdots + M^{1})N + N \\
%	&= \text{(by distributive law)} \\ 
%	&= M^{k+1}N + (M^{k} + M^{k-1} + \cdots + M^{1})N + N \\
%	&= M^{k+1}N + (M^{k} + M^{k-1} + \cdots + M^{1} + 1)N \\
%	&= \text{by }(M^{0} = \epsilon = 1) \\
%	&= M^{k+1}N + (M^{k} + M^{k-1} + \cdots + M^{1} + \epsilon)N \\
%	&= M^{k+1}N + M^{*}N \\
%	&= \text{(by $L = M^{*}N$)} \\
%	&= M^{k+1}N + L
%	\end{align*}  
%	$k\geq 0$
%	$$L = M^{k+1}L + (M^{k} + M^{k-1} + \cdots + M + \epsilon)N$$ 

\end{solution}

\chapter{From \cite{蒋宗礼2013}}

\section{递归定义(recurisive definition)与归纳证明}
\begin{itemize}
	\item 递归定义(recurisive definition)
	\begin{itemize}
		\item 又称为归纳定义(indutive definition),它来定义一个集合。
		\item 集合的递归定义由三个部分组成：
		\begin{itemize}
			\item 基础(basis): 用来定义该集合的最基本的元素。
			\item 归纳(induction): 指出用集合中的元素来构造集合的新元素的规则。
			\item 极小性限定: 指出一个对象是所定义集合中的元素的充要条件是它可以通过有限次的使用基础和归纳条款中所给的规定构造出来。
		\end{itemize}
	\end{itemize}
    \item 归纳证明
    \begin{itemize}
    	\item 与递归定义相对应
    	\item 归纳证明方法包括三大步:
    	\begin{itemize}
    		\item 基础(basis): 证明最基本元素具有相应性质。
    		\item 归纳(induction): 证明如果某些元素具有相应性质，则根据这些元素用所规定的方法得到新元素也有相应的性质。
    		\item 根据归纳法原理，所有的元素具有相应的性质。
    	\end{itemize}
    \end{itemize}
\end{itemize}

\begin{definition}
	设$R$是$S$上的关系，我们递归地定义$R^n$的幂：
	\begin{enumerate}
		\item $R^0 = \{(a,a)|a\in S\}$
		\item $R^i = R^{i-1}R\quad (i=1,2,3,\cdots)$
	\end{enumerate}
\end{definition}

\begin{example}
对有穷集合$A$, 证明$|2^A| = 2^{|A|}$。
\begin{proof}
	设$A$为一个有穷集合，施归纳于$|A|$:
	\begin{enumerate}
		\item 基础: 当$|A|=0$时，$|2^A|=|\{\emptyset \}|=1$。
		\item 归纳: 假设$|A|=n$时结论成立,这里$n\ge 0$,往证当$|A|=n+1$时结论成立
		$$2^A = 2^B \cup \{C\cup \{ a\} | C\in 2^B\}$$
		$$2^B\cap \{C\cup \{a\}|C\in 2^B \} = \emptyset$$
		\begin{align*}
		|2^A|&=|2^B \cup \{C\cup \{ a\} | C\in 2^B\}|\\
		&=|2^B|+|\{C\cup \{a\}|C\in 2^B \}| \\
		&=|2^B|+|2^B| \\
		&=2\ast |2^B| \\
		&=2\ast 2^{|B|} \\
		&=2^{|B|+1}   \\
		&=2^{|A|}
		\end{align*}
		\item 由归纳法原理，结论对任意有穷集合成立。
	\end{enumerate}
\end{proof}	
\end{example}

\section{关系的闭包}
\begin{itemize}
	\item 闭包(closure)
		\subitem 设$P$是关于关系的性质的集合，关系$R$的$P$闭包(closure)是包含$R$并且具有$P$中所有性质的最小关系。
	\item 正闭包(positive closure)
		\subitem(1) $R\subseteq R^{+}$。
		\subitem(2) 如果$(a,b),(b,c) \in R^{+}$,则$(a,c)\in R^{+}$。
		\subitem(3) 除(1)、(2)外，$R^{+}$不包含有其他任何元素。
	\item 传递闭包(transitive closure)
	   	\subitem{-} 具有传递性的闭包。
	   	\subitem{-} $R^{+}$具有传递性。
	\item 可以证明，对任意二元关系$R$,
			$$R^{+} = R\cup R^2 \cup R^3 \cup R^4 \cup \dots$$
	\item 而且当$S$为有穷集时：
			\[R^{+} = R\cup R^2 \cup R^3 \cup \cdots \cup R^{|S|} \]
	\item 克林闭包(Kleene closure) $R^{\ast}$
		\subitem(1) $R^0 \subseteq R^*,R\subseteq R^{\ast}$.
		\subitem(2) 如果$(a,b),(b,c)\in R^{\ast}$则$(a,c)\in R^{\ast}$.
		\subitem(3) 除(1),(2)外，$R^{\ast}$不再含有其他任何元素.
	\item 自反传递闭包(reflexive and transitive closure)
		\subitem $R^{\ast}$具有自反性、传递性。
	\item 可以证明,对任意二元关系$R$,
	\[R^{\ast} =R^{0}\cup R^{+} \]
	\[R^{\ast} =R^{0}\cup R\cup R^{2}\cup R^{3}\cup \dots \]
	\item 而且当$S$为有穷集时:
	\[R^{\ast} =R^{0}\cup R\cup R^{2}\cup R^{3}\cup \dots \cup R^{|S|} \]
	\item $R_1,R_2$是$S$上的两个二元关系
		\subitem(1) $\emptyset^{+}=\emptyset$
		\subitem(2) $(R_1^{+})^{+} = R_1^{+}$
		\subitem(3) $(R_1^{\ast})^{\ast} = R_1^{\ast}$
		\subitem(4) $R_1^{+}\cup R_2^{+} \subseteq (R_1 \cup R_2)^{+}$
		\subitem(5) $R_1^{\ast}\cup R_2^{\ast} \subseteq (R_1\cup R^2)^{\ast}$		
\end{itemize}

\subsection{字母表(alphabet)}
\begin{itemize}
	\item \emph{字母表}是一个非空有穷集合，字母表中的元素称为该字母表的一个\emph{text字母(letter)}。又叫做\emph{符号(symbol)}、或者\emph{字符(character)}。
	\item 非空性
	\item 有穷性
	\item 字符的两个特性
		\subitem{-} 整体性(monolith), 也叫不可分性
		\subitem{-} 可辨认性(distinguishable)，也叫可去区分性
	\item 字母表的乘积(product)
	\[\Sigma_1\Sigma_2 = \{ab|a\in \Sigma_1,b\in \Sigma_2 \} \]
	\item 字母表$\Sigma$的n次幂
		\subitem $\Sigma^0 = \{\epsilon\}$
		\subitem $\Sigma^n = \Sigma^{n-1}\Sigma$
		\subitem $\epsilon$是由$\Sigma$中的0个字符组成的。
	\item $\Sigma$的\emph{正闭包}
		\[\Sigma^{+} = \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \cdots \]
		\[\Sigma^+ = \{x|x\text{是}\Sigma\text{中的至少一个字符连接而成的字符串}\} \]
	\item $\Sigma$的\emph{克林闭包}
		\[\Sigma^{\ast} = \Sigma^0 \cup \Sigma^+ = \Sigma^0 \cup \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \cdots \]
		\[\Sigma^{\ast} = \{x|x\text{是}\Sigma\text{中的若干个，包括0个字符，连接而成的字符串}\} \]
\end{itemize}

\begin{example} \{alphabet\}
	\begin{flushleft}
		\{a,b,c,d\}\\
		\{a,b,c,\dots,z\}\\
		\{0,1\} \\
		\{a,$a^{\prime}$,b,$b^{\prime}$ \}\\
		\{aa,ab,bb \}\\
		$\{\infty,\land,\lor,\geq,\leq \}$
	\end{flushleft}
\end{example}

\begin{example} product
	\begin{flushleft}
		\{0,1\}\{0,1\} = \{00,01,10,00\}\\
		\{0,1\}\{a,b,c,d\} = \{0a,0b,0c,0d,1a,1b,1c,1d\}\\
		\{a,b,c,d\}\{0,1\} = \{a0,a1,b0,b1,c0,c1,d0,d1\}\\
		\{aa,ab,bb\}\{0,1\} = \{aa0,aa1,ab0,ab1,bb0,bb1\}
	\end{flushleft}
\end{example}

\begin{example} $\Sigma^0,\Sigma^{\ast}$ 
	\begin{align*}
	\{0,1\}^+ &= \{0,1,00,01,11,000,001,010,011,100,\dots\}\\
	\{0,1\}^{\ast} &= \{\epsilon,0,1,00,01,11,000,001,010,011,100,\dots\}\\
	\{a,b,c,d\}^+ &= \{a,b,c,d,aa,ab,ac,ad,ba,bb,bc,bd,\dots,aaa,aab,aac,aad,aba,abb,abc,\dots\}\\
	\{a,b,c,d\}^{\ast} &= \{\epsilon,a,b,c,d,aa,ab,ac,ad,ba,bb,bc,bd,\dots,aaa,aab,aac,aad,aba,abb,abc,\dots\}
	\end{align*}
\end{example}

\section{句子(sentence)/字(word)/字符串(string)}
\begin{itemize}
	\item 别称\\
		句子(sentence),(字符、符号)行(line),(字符、符号)串(string).
	\item 句子(sentence)\\
		$\Sigma$是一个字母表,$\forall \in \Sigma^{\ast},x$叫做$\Sigma$上的一个句子。
	\item 句子相等\\
		两个句子被认为相等的，如果它们对应位置上的字符都对应相等。
	\item 句子的长度(length)
		\subitem{-} $\forall x\in \Sigma^{\ast}$,句子$x$中字符出现的总个数叫做该句子的长度,记作$|x|$。
		\subitem{-} 长度为0的字符串叫\emph{空句子},记作$\epsilon$
	\item $\epsilon$是一个句子
	\item $\{\epsilon\}\ne \emptyset$。这是因为$\{\epsilon\}$不是一个空集，它是含有一个空句子的$\epsilon$的集合。$|\{\epsilon\}|=1,|\emptyset|=0$
	\item 串$x$的$n$次幂
	\begin{align*}
	x^0 &= \epsilon \\
	x^n &= x^{n-1}x
	\end{align*}
\end{itemize}

\begin{example}
	$$|abaabb|=6$$
	$$|bbaa|=4$$
	$$|\epsilon|=0$$
\end{example}

\begin{example}
	x=001,y=1101
	\begin{align*}
	x^0 &= y^0 = \epsilon \\
	x^4 &= 001001001001 \\
	y^4 &= 1101110111011101
	\end{align*}
\end{example}

\section{并置/连结(concatenation)}
\begin{itemize}
	\item 并置/连结(concatenation)
	\subitem{-} $x,y\in \Sigma^{\ast},x,y$的并置是由串$x$直接相接串$y$组成的。记作$xy$.
	\item $\Sigma^{\ast}$上的并置运算性质
	\begin{enumerate}
		\item 结合律: $(xy)z=x(yz)$
		\item 左消去律: if $xy=xz$,then $y=z$
		\item 右消去律: if $yx=zx$,then $y=z$
		\item 惟一分解性: 存在惟一确定的$a_1,a_2,\dots,a_n \in \Sigma$,使得$x=a_1a_2\cdots a_n$.
		\item 单位元素: $\epsilon x=x\epsilon=x$
	\end{enumerate} 
\end{itemize}

\section{前缀与后缀}
设$x,y,z,w,v\in \Sigma^{\ast},$且$x=yz,w=yv$
\begin{enumerate}
	\item $y$是$x$的前缀(prefix)
	\item 如果$z\ne \epsilon$,则$y$是x的真前缀(proper prefix).
	\item $z$是$x$的后缀(suffix)
	\item 如果$y\ne \epsilon$,则$z$是$x$的真后缀(proper suffix)
	\item $y$是$x$和$w$的公共前缀(common prefix)
	\item 如果$x$和$w$的任何公共前缀都是$y$的前缀, 则$y$是$x$和$w$的最大公共前缀。
	\item 如果$x=zy$和$w=vy$, 则$y$是$x$和$w$的公共后缀(common suffix)。
	\item 如果$x$和$w$的任何公共后缀都是$y$的后缀, 则$y$是$x$和$w$的最大公共后缀。
\end{enumerate}

\begin{example}
	$\Sigma = \{a,b\}$上的句子abaabb:\\
	前缀: $\epsilon,a,ab,aba,abaa,abaab,abaabb$ \\
	真前缀: $\epsilon,a,ab,aba,abaa,abaab$ \\
	后缀: $\epsilon,b,bb,abb,aabb,baabb,abaabb$ \\
	真后缀: $\epsilon,b,bb,abb,aabb,baabb$
\end{example}

\noindent \textbf{结论}

\begin{enumerate}
	\item $x$的任意前缀$y$有惟一的一个后缀$z$与之对应,使得$x=yz$;反之亦然。
	\item $x$的任意真前缀$y$有惟一的一个真后缀$z$与之对应,使得$x=yz$;反之亦然。
	\item $|\{w|w\text{是}x\text{的后缀}\}| = |\{w|w\text{是}x\text{的前缀}\}|$
	\item $|\{w|w\text{是}x\text{的真后缀}\}| = |\{w|w\text{是}x\text{的真前缀}\}|$
	\item $\{w|w\text{是}x\text{的前缀}\}| = |\{w|w\text{是}x\text{的真前缀}\cup \{x\}\}$
	\item $|\{w|w\text{是}x\text{的前缀}\}| = |\{w|w\text{是}x\text{的真前缀} + 1\}|$
	\item $\{w|w\text{是}x\text{的后缀}\}| = |\{w|w\text{是}x\text{的真后缀}\cup \{x\}\}$
	\item $|\{w|w\text{是}x\text{的后缀}\}| = |\{w|w\text{是}x\text{的真后缀} + 1\}|$
	\item 对于任意字符串$w,w$是自身的前缀,但不是自身的真前缀; $w$是自身的后缀,但不是自身的真后缀。
	\item 对于任意字符串$w,\epsilon$是$w$的前缀,且是$w$的真前缀; $\epsilon$是$w$的后缀,且是$w$的真后缀。
\end{enumerate}

\noindent \textbf{约定}
\begin{itemize}
	\item 用小写字母表中较为靠前的字母$a,b,c,\dots$表示字母表中的字母
	\item 用小写字母表中较为靠后的字母$x,y,z,\dots$表示字母表中的句子(字)
	\item 用$x^T$表示$x$的倒序。例如,如果$x=abc$,则$X^T=cba$
\end{itemize}

\section{子串(substring)}
\begin{itemize}
	\item 子串(substring)
		\subitem{-} $w,x,y,z\in \Sigma^{\ast}$,且$w=xyz$,则称$y$是$w$的子串。
	\item 公共子串(common substring)
		\subitem{-} $t,u,v,w,x,y,z\in \Sigma^{\ast}$,且$t=uyv,w=xyz$,则称$y$是$t$和$w$的公共子串(common substring)。如果$y_1,y_2,\dots,y_n$是$t$和$w$的公共子串,且$max\{|y_1|,|y_2|,\dots,|y_n|\}=|y_j|$,则称$y_j$是$t$和$w$的\emph{最大公共子串}。
		\subitem{-} 两个串的最大公共子串并不一定是惟一的。
\end{itemize}

\section{语言(language)}
$\forall \in\Sigma^{\ast},L$称为字母表$\Sigma$上的一个\emph{语言(language)},$\forall x\in L,x$叫做$L$的一个句子(sentence)/字(word)/字符串(string)。
\begin{example}
	$\Sigma = \{0,1\}$上的不同语言
	\{00,11\}\\
	\{0,1\}\\
	\{0,1,00,11\}\\
	\{0,1,00,11,01,10\}\\
	\{00,11\}$^{\ast}$\\
	\{01,10\}$^{\ast}$\\
	\{00,01,10,11\}$^{\ast}$\\
	\{0\}\{0,1\}$^{\ast}$\{1\}\\
	\{0,1\}$^{\ast}$\{111\}\{0,1\}$^{\ast}$\\
\end{example}

\subsection{语言的\emph{乘积(product)}}
$L_1\subseteq \Sigma_1^{\ast},L_2\subseteq\Sigma_2^{\ast}$,语言$L_1$与$L_2$的\emph{乘积(product)}是一个语言,该语言定义为:
\[L_1L_2=\{xy|x\in L_1,y\in L_2\}\]
是字母表$\Sigma_1\cup\Sigma_2$上的语言。
\begin{example} $\Sigma = \{0,1\}$
	\begin{align*}
	L_1 &=\{0,1\}\\
	L_2 &=\{00,01,10,11\} \\
	L_3 &=\{0,1,00,01,10,11,000,\dots\} =\Sigma^{+} \\
	L_4 &=\{\epsilon,0,1,00,01,10,11,000,\dots\}=\Sigma^{\ast} \\
	L_5 &=\{0^n|n\geq 1\} \\
	L_6 &=\{0^n1^n\geq 1\} \\
	L_7 &=\{1^n|n\geq 1\} \\
	L_8 &=\{0^n1^m|n,m\geq 1\} \\
	L_9 &=\{0^n1^n0^n|n\geq 1\} \\
	L_{10} &=\{0^n1^m0^k|n,m,k\geq 1\} \\
	L_{11}  &=\{x|x\in\Sigma^{+}\text{且$x$中$0$和$1$的个数相同}\}
	\end{align*}
	\begin{itemize}
		\item 上述所有语言都是$L_4$的子集(子语言)；
		\item $L_1,L_2$是有穷语言；其他为无穷语言；其中$L_1$是$\Sigma$上的所有长度为$1$的字组成的语言，$L_2$是$\Sigma$上的所有长度为$2$的字组成的语言；
		\item $L_3,L_4$分别是$\Sigma$的正闭包和克林闭包;
		\item $L_5L_7\ne L_6$,但$L_5L_7=L_8$;同样$L_9\ne L_{10}$,但我们有$L_6\subset L_5L_7, L_9\subset L_{10}$.
		\item $L_6$中的word中的0和1的个数是相同的，并且所有的0在所有的1的前面；$L_{11}$中的word中虽然保持着0和1的个数相同，但它并没有要求所有的0在所有的1的前面。例如，$0101,1100\in L_{11}$,但是$0101\notin L_6$。而对$\forall x\in L_6$,有$x \in L_{11}$。所以$L_6\subset L_{11}$。
	\end{itemize}
\end{example}

\begin{example} $x^T example$
	\begin{enumerate}
		\item $\{x|x=x^T,x\in\Sigma\}$
		\item $\{xx^T|x\in\Sigma^{+}\}$
		\item $\{xx^T|x\in\Sigma^{\ast}\}$
		\item $\{xwx^T|x,w\in\Sigma^{+}\}$
		\item $\{xx^Tw|x,w\in\Sigma^{+}\}$
	\end{enumerate}
\end{example}

\begin{itemize}
	\item 幂
	$\forall L\in\Sigma^{\ast},L$的$n$次\emph{幂}是一个语言，该语言定义为
	\begin{enumerate}
		\item 当$n=0$时，$L^n=\{\epsilon\}$
		\item 当$n\ge 1$时，$L^n=L^{n-1}L$
	\end{enumerate}
	\item 正闭包
	\[L^+=L\cup L^2\cup L^3\cup L^4 \cup\dots\]
	\item 克林闭包
	\[L^{\ast}=L^0\cup L\cup L^2\cup L^3\cup L^4 \cup\dots\]
\end{itemize}

\section{语言的识别}
\begin{itemize}
	\item 识别系统(模型)
	\begin{enumerate}
		\item 系统具有有穷个状态，不同的状态代表不同的意义。按照实际的需要，系统可以在不同的状态下完成规定的任务。
		\item 我们可以将输入字符串中出现的字符汇集在一起构成一个字母表。系统处理的所有字符串都是这个字母表上的字符串。 
		\item 系统在任何一个状态(当前状态)下，从输入字符串中读入一个字符，根据当前状态和读入的这个字符转到新的状态。当前状态和新的状态可以是同一个状态，也可以是不同的状态；当系统从输入字符串中读入一个字符后，它下一次再读时，会读入下一个字符。这就是说，相当于系统维持有一个读写指针，该指针在系统读入一个字符后指向输入串的下一个字符。
		\item 系统中有一个状态，它是系统的开始状态，系统在这个状态下开始进行某个给定句子的处理。 
		\item 系统中还有一些状态表示它到目前为止所读入的字符构成的字符串是语言的一个句子，把所有将系统从开始状态引导到这种状态的字符串放在一起构成一个语言，该语言就是系统所能识别的语言。\item 相应的物理模型
		\begin{enumerate}
			\item 一个右端无穷的输入带。
			\item 一个有穷状态控制器(finite state control,FSC) 。
			\item 一个读头。
		\end{enumerate}
	   \item 系统的每一个动作由三个节拍构成：
	   \begin{enumerate}
	   		\item 读入读头正注视的字符；
	   		\item 根据当前状态和读入的字符改变有穷控制器的状态；
	   		\item 将读头向右移动一格。
	   \end{enumerate}    	
	\end{enumerate}
\end{itemize}
\begin{figure}[htbp]
	\includegraphics*[scale=.4]{anc}
	\caption{系统识别语言$\{a^nc|n\ge 1\}\cup\{a^nd|n\ge 1\}$的字符串中状态的变化}
	\label{fig:anc}       % Give a unique label
\end{figure}

有穷状态自动机的物理模型
\begin{figure}[htbp]
	\includegraphics*[scale=.4]{model}
	\caption{有穷状态自动机的物理模型}
	\label{fig:model}       % Give a unique label
\end{figure}

\section{有穷状态自动机(finite automaton,FA)}
\[M=(Q,\Sigma,\delta,q_0,F)\]

$Q$: 状态的非空有穷集合。$\forall\in Q,q$称为$M$的一个\emph{状态(state)}。

$\Sigma$: \emph{输入字母表(Input alphabet)}。输入字符串都是$\Sigma$上的字符串。

$q_0$: $q_0\in Q$,是$M$的\emph{开始状态(initial state)},也可叫做初始状态或者启动状态。

$\delta$: 状态\emph{转移函数(transition function)}，有时候又叫做状态转换函数或者移动函数。$\delta: Q\times\Sigma\to Q$，对$\forall(q,a)\in Q\times\Sigma,\delta(q,a)=p$表示：$M$在状态$q$读入字符$a$，将状态变成$p$，并将读头向右移动一个带方格而指向输入字符串的下一个字符。

$F$: $F\subseteq Q$，是$M$的\emph{终止状态(final state)}集合。$\forall q\in F, q$称为$M$的终止状态，又称为\emph{接受状态(accept state)}。  

将$\delta$扩充为
\[\hat{\delta}: Q\times\Sigma^{\ast}\to Q\]

对于任意的$q\in Q, w\in\Sigma^{\ast}, a\in\Sigma$，定义
\begin{enumerate}
	\item $\hat{\delta}(q,\epsilon) = q$
	\item $\hat{\delta}(q,wa) = \delta(\hat{\delta}(q,w),a)$
\end{enumerate}
\begin{align*}
 \hat{\delta}(q,a) &= \hat{\delta}(q,\epsilon a) \\
 				   &= \delta(\hat{\delta}(q,\epsilon),a) \\
 				   &= \delta(q,a)
\end{align*}

两值相同，不用区分这两个符号。 

\textbf{确定的有穷状态自动机}

由于对于任意的$q\in Q, a\in\Sigma, \delta(q,a)$均有确定的值，所以，将这种FA称为\emph{确定的有穷状态自动机(deterministic finite automaton，DFA) }

\textbf{$M$接受(识别)的语言}

对于$\forall x\in\Sigma^{\ast}$如果$\delta(q,w)\in F$，则称$x$被$M$接受，如果$\delta(q,w)\notin F$, 则称$M$不接受$x$。
\[L(M)=\{x|x\in\Sigma^{\ast},\text{且}\delta(q,w)\in F\}\]

称为由$M$接受(识别)的语言 

\[L(M_1)=L(M_2)=\{2^{2^n}|n\ge 1\}\]

如果$L(M_1)=L(M_2)$,则称$M_1$与$M_2$等价。

\begin{example}构造一个$DFA$，它接受的语言为
	\[\{x000y|x,y\in\{0,1\}^{\ast}\}\]
	\begin{itemize}
		\item $q_0$: $M$的启动状态；
	    \item $q_1$: $M$读到了一个0，这个0可能是子串“000”的第1个0；
	    \item $q_2$: $M$在$q_1$后紧接着又读到了一个0，这个0可能是子串“000”的第2个0；
		\item $q_3$: $M$在$q_2$后紧接着又读到了一个0，发现输入字符串含有子串“000”；因此，这个状态应该是终止状态。
	    \item $\delta(q_0,1)= q_0$: $M$在$q_0$读到了一个1，它需要继续在$q_0$ “等待”可能是子串“000”的第1个0的输入字符0；
		\item $\delta(q_1,1)= q_0$: $M$在刚刚读到了一个0后，读到了一个1，表明在读入这个1之前所读入的0并不是子串“000”的第1个0，因此，$M$需要重新回到状态$q_0$，以寻找子串“000”的第1个0；
		
		\item $\delta(q_2,1)= q_0$: $M$在刚刚发现了00后，读到了一个1，表明在读入这个1之前所读入的00并不是子串“000”的前两个0，因此，M需要重新回到状态$q_0$，以寻找子串“000”的第1个0；
		
		\item $\delta(q_3,0)= q_3$: $M$找到了子串“000”，只用读入该串的剩余部分。
		
		\item $\delta(q_3,1)= q_3$: $M$找到了子串“000”，只用读入该串的剩余部分。	
	\end{itemize}
	\begin{align*} 
	M=&(\{q_0,q_1,q_2,q_3\},\{0,1\},\\
	&\{\delta(q_0,0)=q_1,\delta(q_1,0)=q_2,\delta(q_2,0)=q_3,\\
	&\delta(q_0,1)=q_0,\delta(q_1,1)=q_0,\delta(q_2,1)=q_0,\\
	&\delta(q_3,0)=q_3,\delta(q_3,1)=q_3\},\\
	&q_0,\{q_3\})
	\end{align*}
	
	see: figure(\ref{fig:x000y}),table(\ref{tab:x000y})
	\begin{table}
		\caption{状态转移表}
		\label{tab:x000y}       % Give a unique label
		\begin{tabular}{|p{1.3cm}|p{0.7cm}|p{0.7cm}|p{0.7cm}|}
		%\begin{tabular}{|c|c|c|c|}
			\hline 
			状态说明 & 状态 & \multicolumn{2}{c|}{输入字符} \\ 
			\hline 
			&  & 0 & 1 \\ 
			\hline 
			开始状态 & $q_0$ & $q_1$ & $q_0$ \\ 
			\hline 
			& $q_1$ & $q_2$ & $q_0$ \\ 
			\hline 
			& $q_2$ & $q_3$ & $q_0$ \\ 
			\hline 
			终止状态 & $q_3$ & $q_3$ & $q_3$ \\ 
			\hline 
		\end{tabular} 
    \end{table}
    \begin{figure}[htbp]
    	\includegraphics*[scale=.4]{x000y}
    	\caption{识别语言\{$x000y|x,y\in\{0,1\}^{\ast}$\}的$DFA$}
    	\label{fig:x000y}       % Give a unique label
    \end{figure}
\end{example}

\begin{example}构造一个$DFA$，它接受的语言为
	\[\{x000|x\in\{0,1\}^{\ast}\}\]
	
	see: figure(\ref{fig:x000})
	\begin{figure}[htbp]
		\includegraphics*[scale=.4]{x000}
		\caption{识别语言\{$x000|x\in\{0,1\}^{\ast}$\}的$DFA$}
		\label{fig:x000}       % Give a unique label
	\end{figure}
\end{example}

\begin{note}\emph{几点值得注意}
	\begin{enumerate}
		\item 定义$FA$时，常常只给出$FA$相应的状态转移图就可以了。 
		\item 对于$DFA$来说，并行的弧按其上的标记字符的个数计算，对于每个顶点来说，它的出度恰好等于输入字母表中所含的字符的个数。 
		
	\end{enumerate}
\end{note}

\section{正则代换(regular substitution)}

设$\Sigma,\Delta$是两个字母表，映射
$$f:\Sigma \to 2^{\Delta^{\ast}}$$
被称为是从$\Sigma$到$\Delta$的
\textbf{代换}。如果对于$\forall a\in \Sigma,f(a)$是$\Delta$上的$RL$,则称\textbf{$f$为正则代换}。

\begin{itemize}
	\item 现将$f$的定义域扩展到$\Sigma^{\ast}$上:
	\begin{enumerate}
		\item $f(\epsilon) =\{\epsilon\}$
		\item $f(xa)=f(x)f(a)$
	\end{enumerate}
    \item 再将$f$的定义域扩展到$2^{\Delta^{\ast}}$\\
    对于$\forall L\subseteq \Sigma{\ast}$\\
    $f(L) = \bigcup\limits_{x\in L} f(x)$
    \item $f$是正则代换，则
    \begin{enumerate}
    	\item $f(\emptyset)=\emptyset$
    	\item $f(\epsilon)=\epsilon$
    	\item 对于$\forall a\in \Sigma,f(a)$是$\Delta$上的$RE$
    	\item 如果$r,s$是$\Sigma$上的$RE$,则\\
    	$f(r+s)=f(r)+f(s)$\\
    	$f(rs)=f(r)f(s)$\\
    	$f(r^{\ast}={f(r)}^{\ast}$\\
    	是$\Delta$上的$RE$
    \end{enumerate}
\end{itemize}

\begin{example}
	设$\Sigma={0,1},\Delta={a,b},f(0)=a,f(1)=b^{\ast}$, 则
	\begin{align*}
		f(010) &= f(0)f(1)f(0)=ab^{\ast}a\\
		f({11,00})&=f(11)\cup f(00) \\
		          &=f(1)f(1)\cup f(0)f(0)\\
		          &=b^{\ast}b^{\ast}+aa = b^{\ast}+aa \\
		f(L(0^{\ast}(0+1)1^{\ast})) &= L(a^{\ast}(a+b^{\ast}){(b^{\ast})}^{\ast})\\
		&= L(a^{\ast}(a+b^{\ast})b^{\ast})\\
		&= L(a^{\ast}ab^{\ast} + a^{\ast}b^{\ast}b^{\ast})\\
		&= L(a^{\ast}b^{\ast})
	\end{align*}
\end{example}

\begin{theorem}
	设$L$是$\Sigma$上的一个$RL$
	$$f:\Sigma \to 2^{\Delta^{\ast}}$$
	是正则代换，则$f(L)$也是$RL$. \hfill$\square$ 
\end{theorem}
\begin{proof}
	描述工具$RE$
	
	对$r$中运算符的个数$n$施以归纳,证明$f(r)$是表示$f(L)$的$RE$.
	\begin{itemize}
		\item 当$n=0$时, 结论成立。
		\item 当$n\le k$时，定理成立，即当$r$中运算符的个数不大于$k$时：$f(L(r)) = L(f(r))$。
		\item 当$n=k+1$时，
		\begin{enumerate}
			\item $r=r_1 + r_2$
			\begin{align*}
			f(L) &= f(L(r)) \\
			&=f(L(r_1 + r_2))\\
			&=f(L(r_1)\cup L(r_2))  &\qquad  \text{$RE$的定义} \\
			&=f(L(r_1))\cup f(L(r_2)) &\qquad \text{正则代换的定义} \\
			&=L(f(r_1))\cup L(f(r_2)) &\qquad \text{归纳假设} \\
			&=L(f(r_1)+f(r_2)) &\qquad RE\text{的定义} \\
			&=L(f(r_1+r_2)) &\qquad RE\text{的正则代换的定义} \\
			&=L(f(r))
			\end{align*}
			
			\item $r=r_1r_2$
			\begin{align*}
			f(L) &=f(L(r)) \\
			&=f(L(r_1r_2))\\
			&=f(L(r_1)L(r2)) &\qquad \text{$RE$的定义}\\
			&=f(L(r_1))f(L(r_2)) &\qquad \text{正则代换的定义}\\
			&=L(f(r_1))L(f(r_2)) &\qquad \text{归纳假设} \\
			&=L(f(r_1)f(r_2)) &\qquad \text{$RE$的定义}\\
			&=L(f(r_1r_2)) &\qquad \text{$RE$的正则代换的定义}\\
			&=L(f(r_1r_2))
			\end{align*}
			
			\item $r={r_1}^{\ast}$
			\begin{align*}
			f(L) &=f(L(r)) \\
			&=f(L({r_1}^{\ast}))\\
			&=f(L({r_1})^{\ast}) &\qquad \text{$RE$的定义}\\
			&={(f(L({r_1})))}^{\ast} &\qquad \text{正则代换的定义}\\
			&={(L(f(r_1)))}^{\ast} &\qquad \text{归纳假设} \\
			&=L(f(r_1)^{\ast}) &\qquad \text{$RE$的定义}\\
			&=L(f({r_1}^{\ast})) &\qquad \text{$RE$的正则代换的定义}\\
			&=L(f(r))
			\end{align*}
		\end{enumerate}
	\end{itemize}  \hfill$\square$ 
\end{proof}

%\input{referenc}

\begin{thebibliography}{99}
	\bibitem[Hopcroft2008]{Hopcroft2008}
	John E. Hopcroft,Rajeev Motwani,Jeffrey D. Ullman著,孙家骕等译,\textit{自动机理论、语言和计算机导论},Third Edition, 机械工业出版社,2008.7
	
	\bibitem[WATSON93a]{WATSON93a}
	WATSON, B. W. \textit{A taxonomy of finite automata construction algorithms}, Computing Science Note 93/43, Eindhoven University of Technology, The Netherlands, 1993. Available by ftp from ftp.win.tue.nl in pub/techreports/pi.
	
	\bibitem[WATSON93b]{WATSON93b}
	WATSON, B. W. \textit{A taxonomy of finite automata minimization algorithms}, Computing Science Note 93/44, Eindhoven University of Technology, The Netherlands, 1993. Available by ftp from ftp.win.tue.nl in pub/techreports/pi.
	
	\bibitem[WATSON94a]{WATSON94a}
	WATSON, B. W. \textit{An introduction to the FIRE engine: A C++ toolkit for FInite automata and Regular Expressions}, Computing Science Note 94/21, Eindhoven University of Technology, The Netherlands, 1994. Available by ftp from ftp.win.tue.nl in pub/techreports/pi
	
	\bibitem[WATSON94b]{WATSON94b}
	WATSON, B.W. \textit{The design. and implementation of the FIRE engine:	A C++ toolkit for FInite automata and Regular Expressions}, Computing Science Note 94/22, Eindhoven University of Technology, The Netherlands, 1994. Available by ftp from ftp.win.tue.nl in pub/techreports/pi.
	
	\bibitem[Chrison2007]{Chrison2007}
	Christos G. Cassandras and St$\acute{e}$phane Lafortune, \textit{Introduction to Discrete Event Systems},Second Edition,New York,Springer,2007
	
	\bibitem[Wonham2018]{Wonham2018}
	W. M. Wonham and Kai Cai,\textit{Supervisory Control of Discrete-Event Systems}, Revised 2018.01.01
	
	\bibitem[Jean2018]{Jean2018}
	Jean-$\acute{E}$ric Pin, \textit{Mathematical Foundations of Automata Theory},Version of June 15,2018
	
	\bibitem[蒋宗礼2013]{蒋宗礼2013}
	蒋宗礼,姜守旭, \textit{形式语言与自动机理论（第3版）}, 清华大学出版社,2013.05
	
	
	\bibitem{Lipschutz2007}
	S. Lipschutz and M. L. Lipson, \textit{Schaum's Outline of Theory and Problems of Discrete Mathematics}, Third Edition, New York: McGraw-Hill, 2007.
	
	\bibitem{Rosen2007}
	K. H. Rosen, \textit{Discrete Mathematics and Its Applications}, Seventh Edition, New York: McGraw-Hill, 2007.
	
	\bibitem{Maclane1988}
	S. Maclane and G. Birkhoff, \textit{Algebra}, Third Edition, New York: Bchelsea Publishing Company, 1988.
\end{thebibliography}


