\chapter{\cite{蒋宗礼2013}(第3章 有穷状态自动机)}

\emph{主要内容}
\begin{itemize} 
	\item 确定的有穷状态自动机$(DFA)$
		\subitem{-} 作为对实际问题的抽象、直观物理模型、形式定义，DFA接受的句子、语言，状态转移图。
	\item 不确定的有穷状态自动机($NFA$)
		\subitem{-} 定义；
		\subitem{-} NFA与DFA的等价性；
	\item 带空移动的有穷状态自动机($\epsilon-NFA$)
		\subitem{-} 定义。
		\subitem{-} $\epsilon-NFA$与$DFA$的等价性。
	\item $FA$是正则语言的识别器
		\subitem{-} 正则文法($RG$)与$FA$的等价性。
		\subitem{-} 相互转换方法。
		\subitem{-} 带输出的有穷状态自动机。
		\subitem{-} 双向有穷状态自动机。
	\item 重点：$DFA$的概念，$DFA$、$NFA$、$\epsilon-NFA$、$RG$之间的等价转换思路与方法。
	\item 难点：对$DFA$概念的理解，$DFA$、$RG$的构造方法， $RG$与$FA$的等价性证明。
\end{itemize}

\section{语言的识别}

\begin{svgraybox}
	设文法$G$有如下产生式: 
	
	$S\to aA|aB$\\
	$A\to aA|c$\\
	$B\to aB|d$
	
	分析句子(word)$aaad$的过程中可能需要回溯。
	\begin{align}
		S &\Rightarrow aA \quad &\text{使用产生式}S\to aA \\
		  &\Rightarrow aaA \quad &\text{使用产生式}A\to aA \label{aA2}\\
		  &\Rightarrow aaaA \quad &\text{使用产生式}A\to aA \label{aA3}\\
		  &\Rightarrow aaaaA \quad &\text{使用产生式}A\to aA, \text{error! return to (\ref{aA3}) step.} \\
		  &\Rightarrow aaac \quad &\text{使用产生式}A\to c, \text{error! return to (\ref{aA3})} step. \\
		  &\cdots\\
		  &\Rightarrow aB \quad &\text{使用产生式}S\to aB \\
		  &\cdots\\
	\end{align}
	
	每一步推导有两种不同的产生式可供选择，共有$2^4=16$种“需要考虑的”不同推导。

	\emph{推导和归约中的回溯问题将对系统的效率产生极大的影响!} 
\end{svgraybox}

\begin{itemize}
	\item 识别系统(模型)
	\begin{enumerate}
		\item 系统具有有穷个状态，不同的状态代表不同的意义。按照实际的需要，系统可以在不同的状态下完成规定的任务。
		\item 我们可以将输入字符串中出现的字符汇集在一起构成一个字母表。系统处理的所有字符串都是这个字母表上的字符串。 
		\item 系统在任何一个状态(当前状态)下，从输入字符串中读入一个字符，根据当前状态和读入的这个字符转到新的状态。当前状态和新的状态可以是同一个状态，也可以是不同的状态；当系统从输入字符串中读入一个字符后，它下一次再读时，会读入下一个字符。这就是说，相当于系统维持有一个读写指针，该指针在系统读入一个字符后指向输入串的下一个字符。
		\item 系统中有一个状态，它是系统的开始状态，系统在这个状态下开始进行某个给定句子的处理。 
		\item 系统中还有一些状态表示它到目前为止所读入的字符构成的字符串是语言的一个句子，把所有将系统从开始状态引导到这种状态的字符串放在一起构成一个语言，该语言就是系统所能识别的语言。\item 相应的物理模型
		\begin{enumerate}
			\item 一个右端无穷的输入带。
			\item 一个有穷状态控制器(finite state control,FSC) 。
			\item 一个读头。
		\end{enumerate}
	   \item 系统的每一个动作由三个节拍构成：
	   \begin{enumerate}
	   		\item 读入读头正注视的字符；
	   		\item 根据当前状态和读入的字符改变有穷控制器的状态；
	   		\item 将读头向右移动一格。
	   \end{enumerate}    	
	\end{enumerate}
\end{itemize}

系统识别语言$\{a^nc|n\ge 1\}\cup\{a^nd|n\ge 1\}$的字符串中状态的变化(figure \ref{fig:anc})
\begin{figure}[htbp]
	\includegraphics*[scale=.4]{anc}
	\caption{系统识别语言$\{a^nc|n\ge 1\}\cup\{a^nd|n\ge 1\}$的字符串中状态的变化}
	\label{fig:anc}       % Give a unique label
\end{figure}

\textbf{有穷状态自动机的物理模型}
\begin{figure}[htbp]
	\includegraphics*[scale=.4]{model}
	\caption{有穷状态自动机的物理模型}
	\label{fig:model}       % Give a unique label
\end{figure}

\section{有穷状态自动机(finite automaton,FA)}
\begin{definition}有穷状态自动机(finite automaton,$FA$)$M$是一个五元组
	\[M=(Q,\Sigma,\delta,q_0,F)\]
	
	$Q$: 状态的非空有穷集合。$\forall\in Q,q$称为$M$的一个\emph{状态(state)}。
	
	$\Sigma$: \emph{输入字母表(Input alphabet)}。输入字符串都是$\Sigma$上的字符串。
	
	$q_0$: $q_0\in Q$,是$M$的\emph{开始状态(initial state)},也可叫做初始状态或者启动状态。
	
	$\delta$: 状态\emph{转移函数(transition function)}，有时候又叫做状态转换函数或者移动函数。$\delta: Q\times\Sigma\to Q$，对$\forall(q,a)\in Q\times\Sigma,\delta(q,a)=p$表示：$M$在状态$q$读入字符$a$，将状态变成$p$，并将读头向右移动一个带方格而指向输入字符串的下一个字符。
	
	$F$: $F\subseteq Q$，是$M$的\emph{终止状态(final state)}集合。$\forall q\in F, q$称为$M$的终止状态，又称为\emph{接受状态(accept state)}。  
\end{definition}

\begin{note}
	应当指出的是，虽然将$F$中的状态称为，终止状态，并不是说$M$一旦进入这种状态就终止了，而是说$M$一旦在处理完输入字符串时到达这种状态，$M$就接受当前处理的字符串。所以，有时又称终止状态为接受状态。
\end{note}

将$\delta$扩充为
\[\hat{\delta}: Q\times\Sigma^{\ast}\to Q\]

对于任意的$q\in Q, w\in\Sigma^{\ast}, a\in\Sigma$，定义
\begin{enumerate}
	\item $\hat{\delta}(q,\epsilon) = q$
	\item $\hat{\delta}(q,wa) = \delta(\hat{\delta}(q,w),a)$
\end{enumerate}
\begin{align*}
 \hat{\delta}(q,a) &= \hat{\delta}(q,\epsilon a) \\
 				   &= \delta(\hat{\delta}(q,\epsilon),a) \\
 				   &= \delta(q,a)
\end{align*}

两值相同，不用区分这两个符号。 

\paragraph{\textbf{确定的有穷状态自动机}}
由于对于任意的$q\in Q, a\in\Sigma, \delta(q,a)$均有确定的值，所以，将这种FA称为\emph{确定的有穷状态自动机(deterministic finite automaton，DFA) }

\paragraph{\textbf{$M$接受(识别)的语言}}

\begin{definition}
	设$M=(Q,\Sigma,\delta,q_0,F)$是一个$FA$。对于$\forall x\in\Sigma^{\ast}$如果$\delta(q,w)\in F$，则称$x$被$M$接受，如果$\delta(q,w)\notin F$, 则称$M$不接受$x$。
	\[L(M)=\{x|x\in\Sigma^{\ast},\text{且}\delta(q,w)\in F\}\]
	称为由$M$接受(识别)的语言
\end{definition}

\begin{example}
	\begin{align*} 
		M_1=&(\{q_0,q_1,q_2\},\{0\},\\
		&\{\delta(q_0,0)=q_1,\delta(q_1,0)=q_2,\delta(q_2,0)=q_1\},\\
		&q_0,\{q_2\})\\
		M_2=&(\{q_0,q_1,q_2,q_3\},\{0,1,2\},\\
		&\{\delta(q_0,0)=q_1,\delta(q_1,0)=q_2,\delta(q_2,0)=q_3,\delta(q_3,0)=q_3\\
		&\delta(q_0,1)=q_3,\delta(q_1,1)=q_3,\delta(q_2,1)=q_3,\delta(q_3,1)=q_3,\\
		&\delta(q_0,2)=q_3,\delta(q_1,2)=q_3,\delta(q_2,2)=q_3,\delta(q_3,2)=q_3\},\\
		&q_0,\{q_2\})\qquad \textit{$q_3$ is a trap/dump state.}  
	\end{align*}
	不难看出: $M_1,M_2$所接受的语言为:
	\[L(M_1)=L(M_2)=\{0^{2n}|n\ge 1\}\]
\end{example}

\begin{definition}\label{M_equivalence}
	如果$L(M_1)=L(M_2)$,则称$M_1$与$M_2$等价。
\end{definition}


\begin{example}构造一个$DFA$，它接受的语言为
	\[\{x000y|x,y\in\{0,1\}^{\ast}\}\]
	\begin{itemize}
		\item $q_0$: $M$的启动状态；
	    \item $q_1$: $M$读到了一个0，这个0可能是子串“000”的第1个0；
	    \item $q_2$: $M$在$q_1$后紧接着又读到了一个0，这个0可能是子串“000”的第2个0；
		\item $q_3$: $M$在$q_2$后紧接着又读到了一个0，发现输入字符串含有子串“000”；因此，这个状态应该是终止状态。
	    \item $\delta(q_0,1)= q_0$: $M$在$q_0$读到了一个1，它需要继续在$q_0$ “等待”可能是子串“000”的第1个0的输入字符0；
		\item $\delta(q_1,1)= q_0$: $M$在刚刚读到了一个0后，读到了一个1，表明在读入这个1之前所读入的0并不是子串“000”的第1个0，因此，$M$需要重新回到状态$q_0$，以寻找子串“000”的第1个0；
		
		\item $\delta(q_2,1)= q_0$: $M$在刚刚发现了00后，读到了一个1，表明在读入这个1之前所读入的00并不是子串“000”的前两个0，因此，M需要重新回到状态$q_0$，以寻找子串“000”的第1个0；
		
		\item $\delta(q_3,0)= q_3$: $M$找到了子串“000”，只用读入该串的剩余部分。
		
		\item $\delta(q_3,1)= q_3$: $M$找到了子串“000”，只用读入该串的剩余部分。	
	\end{itemize}
	\begin{align*} 
	M=&(\{q_0,q_1,q_2,q_3\},\{0,1\},\\
	&\{\delta(q_0,0)=q_1,\delta(q_1,0)=q_2,\delta(q_2,0)=q_3,\\
	&\delta(q_0,1)=q_0,\delta(q_1,1)=q_0,\delta(q_2,1)=q_0,\\
	&\delta(q_3,0)=q_3,\delta(q_3,1)=q_3\},\\
	&q_0,\{q_3\})
	\end{align*}
	
	see: figure(\ref{fig:x000y}),table(\ref{tab:x000y})
	\begin{table}
		\caption{状态转移表}
		\label{tab:x000y}       % Give a unique label
		\begin{tabular}{|p{1.3cm}|p{0.7cm}|p{0.7cm}|p{0.7cm}|}
		%\begin{tabular}{|c|c|c|c|}
			\hline 
			状态说明 & 状态 & \multicolumn{2}{c|}{输入字符} \\ 
			\hline 
			&  & 0 & 1 \\ 
			\hline 
			开始状态 & $q_0$ & $q_1$ & $q_0$ \\ 
			\hline 
			& $q_1$ & $q_2$ & $q_0$ \\ 
			\hline 
			& $q_2$ & $q_3$ & $q_0$ \\ 
			\hline 
			终止状态 & $q_3$ & $q_3$ & $q_3$ \\ 
			\hline 
		\end{tabular} 
    \end{table}
    \begin{figure}[htbp]
    	\includegraphics*[scale=.4]{x000y}
    	\caption{识别语言\{$x000y|x,y\in\{0,1\}^{\ast}$\}的$DFA$}
    	\label{fig:x000y}       % Give a unique label
    \end{figure}
\end{example}

\begin{example}构造一个$DFA$，它接受的语言为
	\[\{x000|x\in\{0,1\}^{\ast}\}\]
	
	see: figure(\ref{fig:x000})
	\begin{figure}[htbp]
		\includegraphics*[scale=.4]{x000}
		\caption{识别语言\{$x000|x\in\{0,1\}^{\ast}$\}的$DFA$}
		\label{fig:x000}       % Give a unique label
	\end{figure}
\end{example}

\paragraph{}
\begin{note}\emph{几点值得注意:}
	\begin{enumerate}
		\item 定义$FA$时，常常只给出$FA$相应的状态转移图就可以了。 
		\item 对于$DFA$来说，并行的弧按其上的标记字符的个数计算，对于每个顶点来说，它的出度恰好等于输入字母表中所含的字符的个数。 
		\item 不难看出，字符串$x$被$FA\quad M$接受的充分必要条件是，在$M$的状态转移图中存在一条从开始状态到某一个终止状态的有向路，该有向路上从第1条边到最后一条边的标记依次并置(连接)而构成的字符串$x$。简称此路的标记为$x$。 
		\item 一个$FA$可以有多于1个的终止状态。 
	\end{enumerate}
\end{note}

\begin{definition} 即时描述(instantaneous description，ID)
	
	设$M=(Q,\Sigma,\delta,q_0,F)$是一个$FA$,
	\begin{itemize}
		\item $x,y\in \Sigma^{\ast}, \delta(q_0,x)=q, xqy$称为$M$的一个\emph{即时描述(instantaneous description，ID)}，表示$xy$是$M$正在处理的一个字符串，$x$引导$M$从$q_0$启动并到达状态$q$，$M$当前正注视着$y$的首字符。 
		
		\item 如果$xqay$是$M$的一个即时描述，且$\delta(q,a)=p$, 则$xqay\vdash_Mxapy$。
		\subitem 表示$M$在状态$q$时已经处理完$x$并且读头正指向输入字符a,此时它读入$a$并转入状态$p$，将读头向右移动一格指向$y$的首字符。
		
		\item $\vdash_{M}$看成是$M$的所有即时描述集合上的二元关系，并用$\vdash_M^{n},\vdash_M^{\ast},\vdash_M^{+}$分别表示$(\vdash_M)^{n},(\vdash_M)^{\ast},(\vdash_M)^{+}$,按照二元关系\emph{合成}的意义，有:
		\subitem $M$存在即时描述$\alpha_1,\alpha_2,\alpha_{n-1}$，使得
		\[\alpha\vdash_M\alpha_1,\alpha_1\vdash_M\alpha_2,\cdots,\alpha_{n-1}\vdash_M\beta\]
		
		\subitem $\alpha\vdash_M^n\beta$: 表示$M$从即时描述$\alpha$经过$n$次移动到达即时描述$\beta$。
		
		\subitem 当$n=0$时，有$\alpha=\beta$, 即$\alpha\vdash_M^0\alpha$
		
		\subitem $\alpha\vdash_M^+\beta$: 表示$M$从即时描述$\alpha$经过至少1次移动到达即时描述$\beta$。
		
		\subitem $\alpha\vdash_M^{\ast}\beta$: 表示$M$从即时描述$\alpha$经过若干步移动到达即时描述$\beta$。
		
		\subitem 当意义清楚时，我们将符号$\vdash_M, \vdash_M^n, \vdash_M^{\ast}, \vdash_M^+$中的$M$省去，分别用$\vdash, \vdash^n, \vdash^\ast, \vdash^+$表示。	
	\end{itemize}
\end{definition}
\begin{example}
	图(\ref{fig:x000ID})的DFA到即时描述(instantaneous description,ID)的转换
	\begin{align*}
		q_0101010001 &\vdash 1 q_0 010010001 \\
		&\vdash 10 q_1 10010001 \\
		&\vdash 101 q_0 0010001 \\
		&\vdash 1010 q_1 010001 \\
		&\vdash 10100 q_2 10001 \\
		&\vdash 101001 q_0 0001 \\
		&\vdash 1010010 q_1 001 \\
		&\vdash 10100100 q_2 01 \\
		&\vdash 101001000 q_3 1 \\
		&\vdash 1010010001 q_0
	\end{align*}
	即
	\begin{align*}
		q_0101010001 &\vdash_{10}1010010001 q_0 \\
		q_0101010001 &\vdash_{+}1010010001 q_0 \\
		q_0101010001 &\vdash_{\ast}1010010001 q_0 
	\end{align*}
	不难证明，对于$x\in\Sigma^{\ast}$,
	\begin{align*}
	q_0x1 &\vdash^{+}x1q_0     \\
	q_0x10 &\vdash^{+}x10q_1   \\
	q_0x100 &\vdash^{+}x100q_2 \\
	q_0x000 &\vdash^{+}x000q_3 
	\end{align*}
	
	\begin{figure}[htbp]
		\includegraphics*[scale=.4]{x000}
		\caption{识别语言\{$x000|x\in\{0,1\}^{\ast}$\}的$DFA$}
		\label{fig:x000ID}       % Give a unique label
	\end{figure}
\end{example}

\begin{definition}\label{set_q}
	设$M=(Q,\Sigma,\delta,q_0,F)$是一个$FA$, 对$\forall q\in Q$，能引导$FA$从开始状态$q_0$到达$q$的字符串的集合为：
\[set(q)=\{x|x\in\Sigma^{\ast},\delta(q_0,x)=q\}\]
\end{definition}

\begin{note}
	根据定义\ref{set_q}，$DFA\quad M$按照语言的特点给出了$\Sigma^\ast$的一个划分，这种划分相当于$\Sigma^\ast$上的一个等价分类，$M$的每个状态实际上对应着相应的等价类。这就告诉我们，用一个状态去表示一个等价类是考虑问题的一个有效思路。	
\end{note}

\begin{example}
	对图\ref{fig:x000ID}所给的$DFA$中的所有$q$，求$set(q)$。
	\begin{align*}
		set(q_0) &=\{x|x\in\Sigma^{\ast},x=\epsilon\text{或者$x$以1结尾}\} \\
		set(q_1) &=\{x|x\in\Sigma^{\ast},x=0\text{或者$x$以10结尾}\} \\
		set(q_2) &=\{x|x\in\Sigma^{\ast},x=00\text{或者$x$以100结尾}\} \\
		set(q_3) &=\{x|x\in\Sigma^{\ast},\text{$x$以000结尾}\} \\
		set(q_4) &=\{x|x\in\Sigma^{\ast},\text{$x$以001结尾}\}
	\end{align*}
	这5个集合是两两互不相交。而且这5个集合的并正好就是该$DFA$的输入字母表$\{0,1\}$的克林闭包。这就是说，这5个集合是$\{0,1\}^\ast$的一个划分。依照这个划分，可以定义一个等价关系，在同一集合中的字符串满足此等价关系，不在同一集合中的字符串不满足此等价关系。
\end{example}

一般地，对于任意一个$DFA,\quad M=(Q,\Sigma,\delta,q_0,F)$ 我们可以按照如下方式定义关系$R_M$:

对$\forall x,y\in\Sigma^{\ast},xR_My \Leftrightarrow \exists q\in Q$，使得$x\in set(q)$和$y\in set(q)$同时成立。

按照这个定义所得到的关系实际上是$\Sigma^{\ast}$上的一个等价关系。利用这个关系，可以将$\Sigma^{\ast}$划分成\emph{不多于}|Q|\emph{个等价类}。 

\begin{example}
	构造一个$DFA$，它接受的语言为$\{0^n1^m2^k|n,m,k\ge 1\}$。 
	$q_0$: $M$的启动状态；
	
	$q_1$: $M$读到至少一个0，并等待读更多的0；
	
	$q_2$: $M$读到至少一个0后，读到了至少一个1，并等待读更多的1；
	
	$q_3$: $M$读到至少一个0后跟至少一个1后，并且接着读到了至少一个2。 
	\begin{itemize}
		\item 先设计“主体框架” ,见图\ref{fig:0n1m2k_1}
		\item 再补充细节, 见图\ref{fig:0n1m2k_2}
	\end{itemize}
	\begin{figure}[htbp]
		\includegraphics*[scale=.4]{0n1m2k_1}
		\caption{接受语言$\{0^n1^m2^k|n,m,k\ge 1\}$的$DFA$的主题框架}
		\label{fig:0n1m2k_1}       % Give a unique label
	\end{figure}

	\begin{figure}[htbp]
		\includegraphics*[scale=.4]{0n1m2k_2}
		\caption{接受语言$\{0^n1^m2^k|n,m,k\ge 1\}$的$DFA$}
		\label{fig:0n1m2k_2}       % Give a unique label
	\end{figure}
\end{example}

本例中有以下几点值得注意：
\begin{enumerate} 
	\item 当$FA$一旦进入状态$q_t$，它就无法离开此状态。所以，$q_t$相当于一个\emph{陷阱状态(trap、dump)}。一般地，我们将陷阱状态用作在其他状态下发现输入串不可能是该$FA$所识别的语言的句子时进入的状态。在此状态下，$FA$读完输入串中剩余的字符。 
	\item  在构造一个识别给定语言的$FA$时，用画图的方式比较方便、直观。我们可以先根据语言的主要特征画出该$FA$的“主体框架”，然后再去考虑画出一些细节要求的内容。
	\item $FA$的状态具有一定的记忆功能：不同的状态对应于不同的情况，由于FA只有有穷个状态，所以，在识别一个语言的过程中，如果有无穷种情况需要记忆，我们肯定是无法构造出相应的$FA$的。如对语言$\{0^n1^n|n\ge 1\}$,当扫描到$n$个0时，需要去寻找$n$个1，由于$n$有无穷多个，所有需要记忆的0的个数有无穷多种。因此，无法构造出接受语言$\{0^n1^n|n\ge 1\}$的$FA$。也就是说，该语言不说属于$FA$可以接受的语言类。 	
\end{enumerate}

\begin{example}
	构造一个$DFA$，它接受的语言为$\{x|x\in \{0,1\}^{\ast}, \text{且当把$x$看成二进制数时，$x$模3与0同余}\}$。 
	
	根据定义\ref{set_q}，$DFA\quad M$按照语言的特点给出了$\Sigma^\ast$的一个划分，这种划分相当于$\Sigma^\ast$上的一个等价分类，$M$的每个状态实际上对应着相应的等价类。这就告诉我们，用一个状态去表示一个等价类是考虑问题的一个有效思路。
	
	题目要求的是$x$模3与0同余，$x$除以3的余数只有3种:0,1,2: 任意一个$x$都不例外，因此可以考虑用3个状态与这3个等价类相联系。
	
	$q_0$: 对应除以3余数为0的$x$组成的等价类，表示十进制值($3n+0|n\in\mathbb{N}$)；
	
	$q_1$: 对应除以3余数为1的$x$组成的等价类，表示十进制值($3n+1|n\in\mathbb{N}$)；
	
	$q_2$: 对应除以3余数为2的$x$组成的等价类，表示十进制值($3n+2|n\in\mathbb{N}$)；
	
	此外，$x$作为一个二进制数，$x$是非空的字符串, 即$\epsilon\notin \{x\}$,所以还需要一个开始状态。
	
	$q_s$: $M$的开始状态。
	
	$q_s$: 在此状态下读入0时，有$x=0$，所以应该进入状态$q_0$；读入1时，有$x=1$，所以应该进入状态$q_1$。即：$\delta(q_s,0)= q_0; δ(q_s,1)= q_1$。
	
	$q_0$: 能引导$M$到达此状态的$x$除以3余0，所以有：$x=3n+0$。
	
	读入0时，引导$M$到达下一个状态的字符串为$x0,x0=2(3n+0)=3\times 2\times n+0$。这表明，$x0$应该属于$q_0$对应的等价类，所以，$M$在$q_0$状态下读入0后，应该继续保持在状态$q_0$,即$\delta(q_0,0)= q_0$；
	
	读入1时，$M$到达下一个状态的字符串为$x1,x1=2(3\times n+0)+1=3\times 2n+1$。这表明，$x1$应该属于$q_1$对应的等价类，所以，，$M$在$q_0$状态下读入1后，应该转到状态$q_1$，即$\delta(q_0,1)= q_1$；
	
	$q_1$: 能引导$M$到达此状态的$x$除以3余1，所以有：$x=3n+1$。
	
	读入0时，引导$M$到达下一个状态的字符串为$x0,x0=2(3n+1)=3\times 2n+2$。所以：$\delta(q_1,0)= q_2$；
	
	读入1时，引导$M$到达下一个状态的字符串为$x1,x1=2(3n+1)+1=3\times 2n+2+1=3(2n+1)$。所以$(q_1,1)= q_0$。 
	
	$q_2$: 能引导$M$到达此状态的$x$除以3余2，所以：$x=3n+2$。
	
	读入0时，引导$M$到达下一个状态的字符串为$x0,x0=2(3n+2)=3\times 2n+4=3(2n+1)+1$。所以$\delta(q_2,0)= q_1$；
	
	读入1时，引导$M$到达下一个状态的字符串为$x1,x1=2(3n+2)+1=3\times 2n+4+1=3(2n+1)+2$。所以，$\delta(q_2,1)= q_2$。
	
	接受的语言$\{x|x\in \{0,1\}^{\ast}, \text{且当把$x$看成二进制数时，$x$模3与0同余}\}$的$DFA$。如图\ref{fig:mod3}。 
	
	\begin{figure}[htbp]
		\includegraphics*[scale=.4]{mod3}
		\caption{接受的语言$\{x|x\in \{0,1\}^{\ast}, \text{且当把$x$看成二进制数时，$x$模3与0同余}\}$的$DFA$}
		\label{fig:mod3}       % Give a unique label
	\end{figure}
\end{example}

\begin{example}
	构造一个DFA,它接受的语言$L=\{x|x\in\{0,1\}^\ast,\\
	\text{且对$x$中任意一个长度不大于5的子串}a_1a_2\dots a_n,a_1+a_2+\cdots+a_n\le 3,n\le 5\}$。
	
	\begin{itemize}
		\item 输入串$a_1a_2\cdots a_i\cdots a_{i+4}a_{i+5}\cdots a_m$
		\item 当$i=1,2,3$，也就是$M$读到输入串的第1,2,3个字符时，它需要将这些字符记下来。因为$a_1\cdots a_i$可能需要用来判定输入串的最初$4\sim 5$个字符组成的子串是否满足语言的要求。 
		\item 当$i=4,5$，也就是$M$读到输入串的第4,5个字符时，在$a_1+a_2+\cdots+a_i\le 3$的情况下，$M$需要将$a_1a_2\cdots a_i$记下来；在$a_1+a_2+\cdots+a_i>3$时，$M$应该进入陷阱状态$q_t$。 
		\item 当$i=6$，也就是$M$读到输入串的第6个字符时，以前读到的第1个字符$a_1$就没用了，此时它要看$a_2+a_3+\cdots+a_6\le 3$是否成立，$M$需要将$a_2a_3\cdots a_6$记下来；在$a_1+a_2+\cdots+a_i>3$时，$M$应该进入陷阱状态$q_t$。
		\item 当$M$完成对子串$a_1a_2\cdots a_i\cdots a_{i+4}$的考察，并发现它满足语言的要求时，$M$记下来的是$a_i\cdots a_{i+4}$，此时它读入输入串的第$i+5$个字符$a_{i+5}$，以前读到的第$i$个字符$a_i$就没有用了，此时它要看$a_{i+1}+a_{i+2}+\cdots+a_{i+5}\le 3$是否成立，如果成立，$M$需要将$a_{i+1},a_{i+2},\cdots,a_{i+5}$记下来；在$a_{i+1}+a_{i+2}+\cdots+a_{i+5}>3$时，$M$应该进入陷阱状态$q_t$。
		
		\item $M$需要记忆的内容是有限多种(共计$1+2+4+8+15+26+1=57$个状态)，分别用不同的状态对应要记忆的不同内容：
		\begin{enumerate}
			\item 什么都未读入——$2^0=1$种；
			\item 记录有1个字符——$2^1=2$种；
			\item 记录有2个字符——$2^2=4$种；
			\item 记录有3个字符——$2^3=8$种；
			\item 记录有4个字符——$2^4-1=15$种；
			\item 记录有5个字符——$2^5-6=26种$；
			\item 记录当前的输入串不是句子(word)——$1$种。 
		\end{enumerate}
	\end{itemize}

	状态设置，为了便于理解，直接用要记忆的内容来区分这些状态:
    \begin{align*}
    	q[\epsilon]: &\text{ $M$还未读入任何字符；}\\
    	q_t: &\text{ 陷阱状态；}\\
    	q[a_1a_2\cdots a_i]: &\text{ $M$记录有$i$个字符}，1\le i\le 5; \quad a_1,a_2,\cdots,a_i \in \{0,1\}.
    \end{align*}
    取$DFA\quad M=(Q,\{0,1\},\delta,q[\epsilon],F)$
    
    $F \{q[\epsilon]\cup\{q[a_1a_2\cdots a_i]|a_1,a_2,\cdots a_i\in\{0,1\}\text{且}1\le i\le 5\text{且}a_1+a_2+\cdots+a_i\le 3\}$
    
    $Q=\{q_t\cup F\}$
    
    $\delta(q[\epsilon],a_1) = q[a_1]$
    
    $\delta(q[a_1],a_2) = q[a_1a_2]$
    
    $\delta(q[a_1a_2],a_3) = q[a_1a_2a_3]$	
    
    $\delta(q[a_1a_2a_3],a) = \begin{cases}
    q[a_1a_2a_3a] &\text{如果$a_1+a_2+a_3+a\le 3$} \\
    q_t &\text{如果$a_1+a_2+a_3+a > 3$}
    \end{cases}$	
    
    $\delta(q[a_1a_2a_3a_4],a) = \begin{cases}
    q[a_1a_2a_3a_4a] &\text{如果$a_1+a_2+a_3+a_4+a\le 3$} \\
    q_t &\text{如果$a_1+a_2+a_3+a_4+a > 3$}
    \end{cases}$
    
    $\delta(q[a_1a_2a_3a_4a_5],a) = \begin{cases}
    q[a_1a_2a_3a_4a_5a] &\text{如果$a_2+a_3+a_4+a_5+a\le 3$} \\
    q_t &\text{如果$a_2+a_3+a_4+a_5+a > 3$}
    \end{cases}$	
    
    $\delta(q[a_t],a_1) = q_t$		
    
    以上各式中,$a,a_1,a_2,a_3,a_4,a_5\in\{0,1\}$。
\end{example}

\section{$NFA$}
\begin{definition}
	不确定的有穷状态自动机(non-deterministic finite automaton,NFA) \
	$M$是一个五元组
	\[M=(Q,\Sigma,\delta,q_0,F)\]
	\begin{itemize}
		\item $Q,\Sigma,q_0,F$的意义同$DFA$。
		\item $Q\times\Sigma\to 2^Q$,对$\forall(q,a)\in Q\times\Sigma,\delta(q,a)=\{p_1,p_2,\cdots,p_m\}$表示$M$在状态$q$读入字符$a$,可以选择地将状态变成$p_1$,或者$p_2,\cdots$,或者$p_m$,并将渡头3向右移动一个带方格而指向输入字符串的下一个字符。
	\end{itemize}
\end{definition}

\begin{note}
	$FA$的状态转移图，$FA$的状态对应的等价类，$FA$的即时描述对$NFA$都有效。
\end{note}

将$\delta$扩充为$\hat{\delta}:Q\times\Sigma\to 2^Q$,对于任意的$q\in Q,w\in\Sigma^\ast,a\in\Sigma$,定义
\begin{enumerate}
	\item $\hat{\delta}(q,\epsilon)=q$
	\item $\hat{\delta}(q,wa)=\{p|r\in(q,w),\text{使得}p\in\delta(r,a)\}$
\end{enumerate}

\begin{align*}
\hat{\delta}(q,a) &=\hat{\delta}(q,\epsilon a)\\
&=\{p|\exists r\in(q,\epsilon),p\in\delta(r,a)\} \\
&=\{p|\exists r\in\{q\},p\in\delta(r,a)\} \\
&=\{p|p\in\delta(q,a)\}\\
&=\delta(q,a)
\end{align*}

和关于$DFA$的结论一样，两值相同，也不用区分这两个符号。 

近一步 扩充$\delta$的定义域: $\delta: 2^Q\times\Sigma^\ast\to 2^Q$. 对任意的$P\subseteq Q,w\in\Sigma^\ast$
\[\delta(P,w)=\bigcup_{q\in P}\delta(q,w)\]

由于,对$\forall(q,w)\in Q\times\Sigma^\ast$
\[\delta(\{q\},w) = \bigcup_{q\in\{q\}}\delta(q,w) = \delta(q,w)\]

所以，不一定严格地区分$\delta$的第1个分量是一个状态还是一个含有一个元素的集合。

对任意的$q\in Q,w\in\Sigma^\ast,a\in\Sigma$:

$\delta(q,wa)=\delta(\delta(q,w),a)$

对输入字符串$a_1a_2\cdots a_n$

$\delta(q,a_1a_2\cdots a_n)=\delta((\cdots\delta(\delta(q,a_1),a_2),\cdots),a_n)$

\begin{definition}
	设$M=(Q,\Sigma,\delta,q_0,F)$是一个$NFA$,对于$\forall x\in\Sigma^\ast$,如果$\delta(q_0,w)\cap F\ne\emptyset$,则称$x$被$M$接受, 如果$\delta(q_0,w)\cap F=\emptyset$,则称$M$不接受$x$。
	\[L(M)=\{x|x\in\Sigma^\ast\text{且}\delta(q_0,w)\cap\ne\emptyset\}\] 
	称为由$M$接受(识别)的语言。
\end{definition}

关于$FA$的等价定义(\ref{M_equivalence})也适应$NFA$

对于一个输入字符，$NFA$与$DFA$的差异是前者可以进入若干个状态，而后者只能进入一个惟一的状态。虽然从$DFA$看待问题的角度来说，$NFA$在某一时刻同时进入若干个状态，但是，这若干个状态合在一起的“总效果”相当于它处于这些状态对应的一个“综合状态”。因此，我们考虑让$DFA$用一个状态去对应$NFA$的一组状态。 

$NFA\quad M_1=(Q,\Sigma,\delta_1,q_0,F_1)$与$DFA\quad M_2=(Q_2,\Sigma,\delta_2,q_0^\prime,F_2)$的对应关系：

$NFA$从开始状态$q_0$启动，我们就让相应的$DFA$从状态$[q_0]$启动。所以$q_0^\prime=[ q_0]$。 

对于$NFA$ 的一个状态组$\{q_1,q_2,\cdots,q_n\}$，如果$NFA$在此状态组时读入字符$a$后可以进入状态组$\{p_1,p_2,\cdots,p_m\}$,则让相应的$DFA$在状态$[q_1,q_2,\cdots,q_n]$读入字符$a$时，进入状态$[p_1,p_2,\cdots,p_m]$。  

\begin{theorem}
	$NFA$与$DFA$等价。
\end{theorem}

\begin{proof}
	显然只需证明对于任给的$NFA$,存在与之等价的$DFA$。为此，设有$NFA:\quad M_1=(Q,\Sigma,\delta_1,q_0,F_1)$
	\begin{enumerate}
		\item 构造与$M_1$等价的$DFA\quad M_2$\\
		取$DFA\quad M_2=(Q_2,\Sigma,\delta_2,[q_0],F_2)$\\
		$Q_2=2^Q$\\
		\footnote[1]{在表示状态集合时暂时将习惯的"\{"和"\}"改为用"["和"]",表示把集合的元素汇集成整体。}
		$F_2=\{[p_1,p_2,\cdots,p_m]|\{p_1,p_2,\cdots,p_m\}\subseteq Q \& \{p_1,p_2,\cdots,p_m\}\cap F_1\ne\emptyset\}$\\
		$\delta_2([q_1,q_2,\cdots,q_n],a)=[p_1,p_2,\cdots,p_m] \Leftrightarrow
		\delta_1(\{q_1,q_2,\cdots,q_n\},a)=\{p_1,p_2,\cdots,p_m\}$
		
		\item[\label{delta_2}] 证明$\delta_1(q_0,x)=\{p_1,p_2,\cdots,p_m\}\Leftrightarrow\delta_2([q_0],x)=[p_1,p_2,\cdots,p_m]$.\\
		设$x\in\Sigma^\ast$,施归纳于$|x|$\\
		$x=\epsilon,\delta_1(q_0,\epsilon)=\{q_0\},\delta_2([q_0],\epsilon)=[q_0]$\\
		设当$|x|=n$时结论成立。下面证明当$|x|=n+1$时结论也成立。不妨设$x=wa,|w|=n,a\in\Sigma$
		\begin{align*}
		\delta_1(q_0,wa) &=\delta_1(\delta_1(q_0,w),a)\\
		&= \delta_1(\{q_1,q_2,\cdots,q_n\},a)\\
		&= \{p_1,p_2,\cdots,p_m\}
		\end{align*}
		由归纳假设，\\
		$\delta_1(q_0,w)=\{q_1,q_2,\cdots,q_n\}\Leftrightarrow\delta_2([q_0],w)=[q_1,q_2,\cdots,q_n]$\\
		根据$\delta_2$的定义, \\
		$\delta_2([q_1,q_2,\cdots,q_n],a)=[p_1,p_2,\cdots,p_m]\Leftrightarrow\delta_1(\{q_1,q_2,\cdots,q_n\},a)=\{p_1,p_2,\cdots,p_m\}$\\
		所以，
		\begin{align*}
		\delta_2([q_0],wa) &=\delta_2(\delta_2([q_0],w),a)\\
		&= \delta_2(\{q_1,q_2,\cdots,q_n\},a)\\
		&= [p_1,p_2,\cdots,p_m]
		\end{align*}
		故，如果$\delta_1([q_0],wa)=\{p_1,p_2,\cdots,p_m\}$则必有$\delta_2([q_0],wa)=[p_1,p_2,\cdots,p_m]$.
		
		由上述推导可知，反向的推导也成立。这就是说，结论对$|x|=n+1$也成立。
		
		由归纳法原理，结论对$x\in\Sigma^\ast$成立。
		
		\item 证明$L(M_1)=L(M_2)$\\
		设$x\in L(M_1)$,且$\delta_1(q_0,x)=\{p_1,p_2,\cdots,p_m\}$,从而$\delta_1(q_0,x)\cap\ne\emptyset$,这就是说，$\{p_1,p_2,\cdots,p_m\}\cap F_1\ne\emptyset$,由$F_2$的定义，$[p_1,p_2,\cdots,p_m]\in F_2$.\\
		再由(\ref{delta_2})知，$\delta_2([q_0],wa)=[p_1,p_2,\cdots,p_m]$.\\
		所以,$x\in L(M_2)$. 故$L(M_1)\subseteq L(M_2)$.\\
		反过来推,可得$L(M_2\subseteq L(M_1))$.\\
		从而$L(M_1)=L(M_2)$得证。
	\end{enumerate}
	综上所述，定理成立。\hfill$\square$
\end{proof}

\section{Exercise and Solution}
\begin{exercise}
	构造识别下列语言的$DFA$(给出相应的$DFA$的形式描述或者画出它们的状态转移图)。
	\begin{enumerate}
		\item $\{0,1\}^+$。
		\item $\{x|x\in\{0,1\}^+\text{且$x$中不含形如$00$的子串}\}$。
		\item $\{x|x\in \{0,1\}^+ \text{且当把$x$看成二进制数时，$x$模5与3同余，}$\\ 
			  要求当$x$为0时，$|x|=1$,且当$x\ne 0$时，$x$的首字符为1\}。
        \item $\{x|x\in\{0,1\}^+\text{且$x$以0开头以1结尾}\}$。
	\end{enumerate}
\end{exercise}
	
\begin{solution} 构造相应语言的$DFA$	
\begin{enumerate}
	\item 构造$\{0,1\}^+$语言的$DFA$,见下表(\ref{tab:s1})。
	\item $\{x|x\in\{0,1\}^+\text{且$x$中不含形如$00$的子串}\}$语言的$DFA$,见下表(\ref{tab:s1})。
	\begin{table}[htbp]
		\caption{构造相应语言的$DFA$}
		\label{tab:s1}
		\centering
	\begin{tabular}{|p{5cm}|p{6cm}|}
		\hline 
		构造$\{0,1\}^+$语言的$DFA$。
		\newline 
		本题的关键是保证接受的串的长度至少为1.
		&
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
		\node[state,initial] (q0) {$q_0$};
		\node[state,accepting](q1) [right=of q0] {$q_1$};
		\path[->]
		(q1) edge [loop above] node {$0,1$} (q1) 
		(q0) edge node {$0,1$} (q1);
		\end{tikzpicture} \\
		\hline 
		构造$\{x|x\in\{0,1\}^+ \newline \text{且$x$中不含形如$00$的子串}\}$语言的$DFA$。 
		\newline 
		构造要点是，自动机启动并读入一个字符后，就将"精力"集中在考察是否出现$00$子串上，一旦发现子串$00$，就进入陷阱状态。
		&
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
		\node[state,initial] (q0) {$q_0$};
		\node[state,accepting](q1) [above right=of q0] {$q_1$};
		\node[state,accepting] (q2) [below=of q1] {$q_2$};
		\node[state](dump) [right=of q2] {$d$};
		\path[->]
		(q0) edge node {$1$} (q1)
		(q0) edge node {$0$} (q2)
		(q1) edge [loop above] node {$1$} (q1)
		(q1) edge [swap] node {$0$} (q2)
		(q2) edge [bend right,swap] node {$1$} (q1)
		(q2) edge node {$0$} (dump)
		(dump) edge [loop above] node {0,1} (dump) ;
		\end{tikzpicture} \\
		\hline
	\end{tabular} 
	\end{table}
\item $\{x|x\in \{0,1\}^+ \text{且当把$x$看成二进制数时，$x$模5与3同余，}$\\ 
	要求当$x$为0时，$|x|=1$,且当$x\ne 0$时，$x$的首字符为1\}。\\
	$DFA$见图(\ref{fig:mod_5}),状态转移表见(\ref{tab:mod_5},\ref{tab:mod_5_1})。构造要点如下:
    \begin{enumerate}
    	\item 以0开头的串都不能被$DFA$接受，包括字符串0，所以，如果$DFA$在启动状态读入的符号为0，则直接进入陷阱状态。
    	\item 该$DFA$共有7种状态：开始状态、陷阱状态、终止状态各一个。在状态转移图中，终止状态和其余4种状态构成最大的强连通子图。
    	\item 模5的等价类：$5n,5n+1,5n+2,5n+3,5n+4$, 其中$n\ge 0$
    \end{enumerate}
    \begin{figure}[htbp]
    	\centering
	    \begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
		    \node[state] (q0) {$q_0$};
		    \node[state,](q1) [below=of q0] {$q_1$};
		    \node[state,accepting] (q3) [below left=of q1] {$q_3$};
		    \node[state] (q2) [below right=of q1] {$q_2$};
		    \node[state] (q4) [below left=of q2] {$q_4$};
		    \node[state,initial] (s) [left=of q1] {$s$};
		    \node[state](dump) [above=of s] {$d$};
		    \path[->]
		    (s) edge node {$0$} (dump)
		    (s) edge node [bend left] {$1$} (q1)
		    (q0) edge [loop above] node {$0$} (q0)
		    (q0) edge [swap] node {$1$} (q1)
		    (q1) edge node {$0$} (q2)
		    (q2) edge node {$0$} (q4)
		    (q4) edge node {$0$} (q3)
		    (q3) edge [bend right,swap] node {$0$} (q1)
		    (q1) edge [swap] node {$1$} (q3)
		    (q2) edge [bend right] node {$1$} (q0)
		    (q3) edge [bend right] node {$1$} (q2)
		    (q4) edge [loop below] node {$1$} (q4)
		    (dump) edge [loop above] node {$0,1$} (dump);
		\end{tikzpicture} 
	\caption{$\{x|x\in \{0,1\}^+ \text{且当把$x$看成二进制数时，$x$模5与3同余，}$\newline
		要求当$x$为0时，$|x|=1$,且当$x\ne 0$时，$x$的首字符为1\}语言对应的$DFA$}
	\label{fig:mod_5}
	\end{figure}
    \begin{table}[htbp]
    	\caption{$\{x|x\in \{0,1\}^+ \text{且当把$x$看成二进制数时，$x$模5与3同余，}$\newline 
    		要求当$x$为0时，$|x|=1$,且当$x\ne 0$时，$x$的首字符为1\}语言对应的$DFA$,状态$q_0,\cdots,q_4$转移表}
    	\label{tab:mod_5}
    	\centering
    	\begin{tabular}{|c||c|c|c|c|c|}
    		\hline
    		state&$q_0$&$q_1$&$q_2$&$q_3$&$q_4$\\
    		\hline
    		意义&$5n$&$5n+1$&$5n+2$&$5n+3(marked)$&$5n+4$\\
    	    \hline
    	    \cline{1-6}  % 画一条横线在1-6列之间
    	    输入字符0&$q_0$&$q_2$&$q_4$&$q_1$&$q_3$\\
    	    \hline
    	    $sx,x=0$&$(5n)\times 2=10n$&$(5n+1)\times 2=10n+2$&$(5n+2)\times 2=10n+4$&$(5n+3)\times 2=10n+6$&$(5n+4)\times 2=10n+8$\\
    	    \hline
    	    \cline{1-6}  % 画一条横线在1-6列之间
    	    输入字符1&$q_1$&$q_3$&$q_0$&$q_2$&$q_4$\\
    	    \hline
    	    $sx,x=1$&$(5n)\times 2+1$&$(5n+1)\times 2+1$&$(5n+2)\times 2+1$&$(5n+3)\times 2+1$&$(5n+4)\times 2+1$\\
    	    %\hline
    	            &$=10n+1$&$=10n+3$&$=10n+5$&$=10n+7$&$=10n+9$\\
    	    \hline
   		\end{tabular} 
	\end{table}	
    \begin{table}[htbp]
    	\caption{$\{x|x\in \{0,1\}^+ \text{且当把$x$看成二进制数时，$x$模5与3同余，}$\newline 
    		要求当$x$为0时，$|x|=1$,且当$x\ne 0$时，$x$的首字符为1\}语言对应的$DFA$,状态$s,d$转移表}
    	\label{tab:mod_5_1}
    	\centering
    	\begin{tabular}{|c||c|c|}
    		\hline
    		state&$s$&$d$\\
    		\hline
    		意义&开始状态&$dump/trap$状态\\
    		\hline
    		\cline{1-3}  % 画一条横线在1-3列之间
    		输入字符0&$d$&$d$\\
    		\hline
    		$sx,x=0$&以0开头的串都不能被$DFA$接受，进入陷阱状态&在陷阱状态输入$0,1$,仍然离不开陷阱状态\\
    		\hline
    		\cline{1-3}  % 画一条横线在1-3列之间
    		输入字符1&$q_1$&$d$\\
    		\hline
    		$sx,x=1$&余1,进入$q_1$&在陷阱状态输入$0,1$,仍然离不开陷阱状态\\
    		\hline
    	\end{tabular} 
    \end{table}	
\item $\{x|x\in\{0,1\}^+\text{且$x$以0开头以1结尾}\}$。\\
	$DFA$见图(\ref{fig:01})。构造要点如下:
	\begin{enumerate}
		\item 启动时，只要考虑开始符号是否为0。
		\item 以1开头的字符串都是不可接受的。
		\item 在读入一个字符0之后，当读到1时，可将这个1先当成结尾的1，如果是，就停止并接受；如果不是，就继续向前扫描。
		\item 被接受串的长度至少为2。
	\end{enumerate}
	\begin{figure}[htbp]
		\centering
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
		\node[state,initial] (q0) {$q_0$};
		\node[state,](q1) [right=of q0] {$q_1$};
		\node[state,accepting] (q2) [right=of q1] {$q_2$};
		\node[state](dump) [below right=of q0] {$d$};
		\path[->]
		(q0) edge node {$0$} (q1)
		(q1) edge node {$1$} (q2)
		(q2) edge [bend left] node {$1$} (q1)
		(q1) edge [loop above] node {$0$} (q1)
		(q2) edge [loop above] node {$1$} (q2)
		(dump) edge [loop below] node {$0,1$} (dump)
		(q0) edge node {$1$} (dump);
		\end{tikzpicture} 
		\caption{$\{x|x\in\{0,1\}^+\text{且$x$以0开头以1结尾}\}$语言对应的$DFA$}
		\label{fig:01}
	\end{figure}
\item $\{x|x\in\{0,1\}^\ast\text{且如果$x$以1结尾,则它的长度为偶数;如果$x$以0结尾,则长度为奇数}\}$。\\
	$DFA$见图(\ref{fig:odd_even})。构造要点如下:
	\begin{enumerate}
		\item 语言根据word长度的奇偶性对字符串的结尾提出要求，因此，它将$\{0,1\}^+$中的字符串分成4个等价类，这4个等价类依次为：
			\begin{enumerate}
				\item \text{[奇0]:} $\{x|x\in\{0,1\}^+ \text{不仅长度为奇数，而且以0结尾}\}$,用$[o0]$表示此等价类及其对应的状态,是终止状态。
				\item \text{[奇1]:} $\{x|x\in\{0,1\}^+ \text{不仅长度为奇数，而且以1结尾}\}$,用$[o1]$表示此等价类及其对应的状态。
				\item \text{[偶0]:} $\{x|x\in\{0,1\}^+ \text{不仅长度为偶数，而且以0结尾}\}$,用$[e0]$表示此等价类及其对应的状态。
				\item \text{[偶1]:} $\{x|x\in\{0,1\}^+ \text{不仅长度为偶数，而且以1结尾}\}$,用$[e1]$表示此等价类及其对应的状态,是终止状态。
			\end{enumerate}
		\item $\epsilon$不属于上述任何一个等价类，所以她自己构成独立地构成一个等价类，而且它是语言的句子($\epsilon \in L(M)$)，该等价类对应的状态为终止状态，用$[\epsilon]$表示此等价类及其对应的状态。
		\item $M=(\{[\epsilon],[o0],[o1],[e0],[e1]\},\{0,1\},\delta,\{[\epsilon],[o0],[e1]\})$,其中$\delta$是状态转移函数，见表(\ref{tab:odd_even})。\\
		如果将长度0看成偶数长，从此表可以明显地看出，在读入一个字符时，已处理的输入串的相应前缀长度的奇偶性“交替变化”：奇变偶，偶变奇。而0,1区分正好体现了读进来的符号:是0就是0，是1就是1.
		\item 如果认为$\epsilon$不属于语言($\epsilon \notin L(M)$)，则只要将$[\epsilon]$从终止状态集中删除即可。	
	\end{enumerate}
	\begin{table}[htbp]
		\caption{$\{x|x\in\{0,1\}^\ast\text{且如果$x$以1结尾,则它的长度为偶数;如果$x$以0结尾,则长度为奇数}\}$转移表}
		\label{tab:odd_even}
		\centering
		\begin{tabular}{|c||c|c|c|c|c|}
			\hline
			state&$[\epsilon]$&$[o0]$&$[o1]$&$[e0]$&$[e1]$\\
			\hline
			意义&空字符串(marked)&奇长,0尾(marked)&奇长,1尾&偶长,0尾&偶长,1尾(marked)\\
			\hline
			\cline{1-6}  % 画一条横线在1-6列之间
			输入字符0&$[o0]$&$[e0]$&$[e0]$&$[o0]$&$[o0]$\\
			\hline
			\cline{1-6}  % 画一条横线在1-6列之间
		    输入字符1&$[o1]$&$[e1]$&$[e1]$&$[o1]$&$[o1]$\\
			\hline
		\end{tabular} 
	\end{table}	
	\begin{figure}[htbp]
		\centering
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
		\node[state,accepting] (o0) {$o0$};
		\node[state](e0) [below=of o0] {$e0$};
		\node[state,accepting] (e1) [right=of o0] {$e1$};
		\node[state] (o1) [below=of e1] {$o1$};
		\node[state,initial] (s) [below left=of e0] {$[\epsilon]$};
		\path[->]
		(s) edge [bend left] node {$0$} (o0)
		(s) edge [bend right] node {$1$} (o1)
		(e0) edge [bend left] node {$0$} (o0)
		(o0) edge [bend left] node {$0$} (e0)
		(e1) edge [bend left] node {$1$} (o1)
		(o1) edge [bend left] node {$1$} (e1)
	
		(o0) edge [bend left] node {$1$} (e1)
		(e1) edge [bend left] node {$0$} (o0)
		
		(e0) edge [bend left] node {$1$} (o1)
		(o1) edge [bend left] node {$0$} (e0);
		\end{tikzpicture} 
		\caption{$\{x|x\in\{0,1\}^\ast\text{且如果$x$以1结尾,则它的长度为偶数;如果$x$以0结尾,则长度为奇数}\}$语言对应的$DFA$($[o0]$奇0,$[o1]$奇1;$[e0]$偶0,$[e1]$偶1)}
		\label{fig:odd_even}
	\end{figure}
\end{enumerate}
\end{solution}

\begin{exercise}
	设$DFA$ $M=(Q,\Sigma,\delta,q_0,F)$，证明：对于$\forall x,y\in\Sigma^\ast,q\in Q$，
	$$\delta(q,xy)=\delta(\delta(q,x),y)$$
\end{exercise}

\begin{solution}
	\begin{proof}
		设$x,y\in\Sigma^\ast,q\in Q$,现对$|y|$施归纳。
		\begin{enumerate}
			\item 当$|y|=0$时，$y=\epsilon$,由于对任意的$q\in Q$, 均有\\
			$\delta(q,\epsilon)=q$\\
			所以
			\begin{equation}\label{key_1}
			\delta(q,x)=\delta(\delta(q,x),\epsilon)
			\end{equation}
			另一方面，$x=x\epsilon$, 使得下式成立
			\begin{equation}\label{key_2}
			\delta(q,x\epsilon)=\delta(q,x)
			\end{equation}
			综合这两个等式(\ref{key_1},\ref{key_2})得
			$$\delta(q,x\epsilon)=\delta(\delta(q,x),\epsilon)$$
			即结论对$|y|=0$成立。
			
			\item 设结论对$|y|=n$成立，且$|ya|=n+1,a\in\Sigma^\ast$，此时由$\delta$的定义\\
			$\delta(q,xya)=\delta(\delta(q,xy),a)$\\
			由归纳假设，$\delta(q,xy)=\delta(\delta(q,x),y)$\\
			从而\\
			$\delta(q,xya)=\delta(\delta(q,xy),a)=\delta(\delta(\delta(q,x),y),a)$\\
			注意到$\delta(q,x)$为一个状态，再由$\delta$的定义\\
			$\delta(\delta(\delta(q,x),y),a)=\delta(\delta(q,x),ya)$\\
			所以\\
			$\delta(\delta(q,xy),a)=\delta(\delta(q,x),ya)$\\
			表明结论对$|ya|=n+1$成立。
		\end{enumerate}
		由归纳法原理，结论对任意的$x,y\in\Sigma^\ast,q\in Q$成立。$\hfill\square$
	\end{proof} 
\end{solution}

\begin{exercise}\label{ex:co}
	证明：对于任意的$DFA$ $M_1=(Q,\Sigma,\delta,q_0,F_1)$,存在$DFA$ $M_2=(Q,\Sigma,\delta,q_0,F_2)$,使得$L(M_2)=\Sigma^\ast-L(M_1)$。
\end{exercise}

\begin{solution}
	\begin{proof}
		分两步证明。
		\begin{enumerate} 
			\item 构造$M_2$\\
			设$DFA$ $M_1=(Q,\Sigma,\delta,q_0,F_1)$\\
			取$DFA$ $M_1=(Q,\Sigma,\delta,q_0,Q-F_2)$
			\item 证明$L(M_2)=\Sigma^\ast-L(M_1)$\\
			对任意的$x\in\Sigma^\ast$,\\
			$x\in L(M_2)=\Sigma^\ast-L(M_1)\Leftrightarrow\delta(q_0,x)\in Q-F\Leftrightarrow\delta(q_0,x)\in Q$并且$\delta(q_0,x)\notin F_1\Leftrightarrow x\in\Sigma^\ast$并且$x\notin L(M_1)\Leftrightarrow x\in\Sigma^\ast-L(M_1)$ $\hfill\square$
		\end{enumerate}
	\end{proof}
\end{solution}	

\begin{exercise}
	对于任意的$DFA$ $M_1=(Q_1,\Sigma,\delta_1,q_{01},F_1)$,请构造$DFA$ $M_2=(Q_2,\Sigma,\delta_2,q_{02},F_2)$,使得$L(M_2)=L(M_1)^T$其中$L(M)^T=\{x|x^T \in L(M)\}$。
\end{exercise}

\begin{solution}
	\begin{proof}
		分三步证明。
		\begin{enumerate} 
			\item 构造$\epsilon-NFA$ $M$使得$L(M)=L(M_1)$\\
			设$DFA$ $M_1=(Q_1,\Sigma,\delta_1,q_{01},F_1)$\\
			先取$\epsilon-NFA$ $M=(Q,\Sigma,\delta,q_0,\{q_{01}\})$,其中\\
			$Q=Q_1\cup\{q_0\},q_0\notin Q_1$\\
			对于任意的$q,p\in Q,a\in\Sigma$,\\
			$q\in\delta(p,a)\Leftrightarrow\delta_1(q,a)=p$\\
			$\delta(q_0,\epsilon)=F_1$
			
			\item 证明$L(M)=L(M_1)^T$\\
			对任意的$a_1a_2\cdots a_n\in\Sigma^\ast$,\\
		    $a_1a_2\cdots a_n\in L(M)\Leftrightarrow q_0a_1a_2\cdots a_n\vdash q_fa_1a_2\cdots a_n\vdash a_1q_1a_2\cdots a_n\vdash a_1a_2q_2\cdots a_n\vdash \cdots \vdash a_1a_2\cdots q_{n-1}a_n\vdash a_1a_2\cdots q_{01}$并且$q_f\in F_1$\\
		    $\Leftrightarrow q_f\in \delta(q_0,\epsilon),q_1\in\delta(q_f,a_1),q_2\in\delta(q_1,a_2),\cdots,q_{01}\in(q_{n-1},a_n)$,并且$q_f\in\delta(F_1)$\\
		    $\Leftrightarrow \delta(q_1,a_1)=q_f,\delta(q_2,a_2)=q_1,\cdots,\delta(q_{01},a_n)=q_{n-1}$,并且$q_f\in F_1$\\
		    $\Leftrightarrow q_{01}a_na_{n-1}\cdots a_1\vdash a_nq_{n-1}a_{n-1}\cdots a_1\vdash\cdots\vdash a_na_{n-1}\cdots q_2a_2a_1\vdash a_na_{n-1}\cdots a_2q_1a_1\vdash a_na_{n-1}\cdots a_2a_1q_f$\\
		    $\Leftrightarrow a_na_{n-1}\cdots a_2a_1\Leftrightarrow x\in L(M_1)$
		    
		    \item 按照将$\epsilon-NFA$转换成等价的$NFA$,再将$NFA$转换成等价的$DFA$的方法，将此$\epsilon-NFA$转换成满足要求的$DFA$ $M_2=(Q_2,\Sigma,\delta_2,q_{02},F_2)$。
		\end{enumerate}
	\end{proof}
\end{solution}

\begin{exercise}
	构造识别下列语言的$NFA$。
	\begin{enumerate}
		\item $\{x|x\in\{0,1\}^+\text{并且$x$中含形如$10110$的子串}\}$。
		\item $\{x|x\in\{0,1\}^+\text{并且$x$中不含形如$10110$的子串}\}$。
		\item $\{x|x\in\{0,1\}^+\text{$x$以0开头以1结尾}\}$。
		\item $\{x|x\in\{0,1\}^\ast\text{且如果$x$以1结尾,则它的长度为偶数;如果$x$以0结尾,则长度为奇数}\}$。
		$\{x|x\in\{0,1\}^+\text{$x$首字符和尾字符形同}\}$。
	\end{enumerate}
\end{exercise}

\begin{solution}
	构造识别下列语言的$NFA$。
	\begin{enumerate}
		\item 构造$\{x|x\in\{0,1\}^+\text{并且$x$中含形如$10110$的子串}\}$语言的$NFA$。构造结果如图(\ref{fig:10110})所示。
		\begin{figure}[htbp]
			\centering
			\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
			\node[state,initial](q0) {$q_0$};
			\node[state](q1) [right of=q0] {$q_1$};
			\node[state](q2) [right of=q1] {$q_2$};
			\node[state](q3) [right of=q2] {$q_3$};
			\node[state](q4) [right of=q3] {$q_4$};
			\node[state,accepting](q5) [right of=q4] {$q_5$};
			\path[->]
			(q0) edge [loop above] node {$0,1$} (q0)
			(q0) edge node {$1$} (q1)
			(q1) edge node {$0$} (q2)
			(q2) edge node {$1$} (q3)
			(q3) edge node {$1$} (q4)
			(q4) edge node {$0$} (q5)
			(q5) edge [loop above] node {$0,1$} (q5);
			\end{tikzpicture} 
			\caption{$\{x|x\in\{0,1\}^+\text{并且$x$中含形如$10110$的子串}\}$语言的$NFA$}
			\label{fig:10110}
		\end{figure}
	
		\item 构造$\{x|x\in\{0,1\}^+\text{并且$x$中不含形如$10110$的子串}\}$语言的$NFA$。\\
		构造要点如下:
		\begin{enumerate}
			\item 虽然本小题的语言是上一小题语言的补，决不能通过将上一小题的所给出的$NFA$的终止状态和非终止状态互换来构造本小题的$NFA$。就是说\textbf{Exercise \ref{ex:co}}所给的方法仅适用于$DFA$,不适用于$NFA$。
			\item 需要构造相应语言的$DFA$,即一种特殊的NFA。如图(\ref{fig:Not10110})所示。
			\item 根据\textbf{Exercise \ref{ex:co}}和上一小题的结果构造主体框架，然后逐步补充。
			\begin{figure}[htbp]
				\centering
				\flushleft{step 1: $F = Q-F$}
				\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
				\node[state,accepting,initial](q0) {$q_0$};
				\node[state,accepting](q1) [right of=q0] {$q_1$};
				\node[state,accepting](q2) [right of=q1] {$q_2$};
				\node[state,accepting](q3) [right of=q2] {$q_3$};
				\node[state,accepting](q4) [right of=q3] {$q_4$};
				\node[state](q5) [right of=q4] {$q_5$};
				\path[->]
				(q0) edge [loop above] node {$0,1$} (q0)
				(q0) edge node {$1$} (q1)
				(q1) edge node {$0$} (q2)
				(q2) edge node {$1$} (q3)
				(q3) edge node {$1$} (q4)
				(q4) edge node {$0$} (q5)
				(q5) edge [loop above] node {$0,1$} (q5);
				\end{tikzpicture} 
				\newline
				\flushleft{step 2: Add new state d, 拆分$q_0$的自环\{0,1\}}
				\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
				\node[state,initial](q0) {$q_0$};
				\node[state,accepting](q1) [right of=q0] {$q_1$};
				\node[state,accepting](q2) [right of=q1] {$q_2$};
				\node[state,accepting](q3) [right of=q2] {$q_3$};
				\node[state,accepting](q4) [right of=q3] {$q_4$};
				\node[state](q5) [right of=q4] {$q_5$};
				\node[state,accepting](d) [below of=q1] {$d$};
				\path[->]
				%(q0) edge [loop above] node {$0,1$} (q0)
				(q0) edge node {$1$} (q1)
				(q1) edge node {$0$} (q2)
				(q2) edge node {$1$} (q3)
				(q3) edge node {$1$} (q4)
				(q4) edge node {$0$} (q5)
				(q5) edge [loop above] node {$0,1$} (q5)
				(q0) edge [bend right] node {$0$} (d);
				\end{tikzpicture} 
				\newline
				\flushleft{step 3: Add self loop in state $q_1$ and $d$。$q_1$表示接受0个或多个$1$的状态，$d$表示接受0个或多个$0$的状态，}
				\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
				\node[state,initial](q0) {$q_0$};
				\node[state,accepting](q1) [right of=q0] {$q_1$};
				\node[state,accepting](q2) [right of=q1] {$q_2$};
				\node[state,accepting](q3) [right of=q2] {$q_3$};
				\node[state,accepting](q4) [right of=q3] {$q_4$};
				\node[state](q5) [right of=q4] {$q_5$};
				\node[state,accepting](d) [below of=q1] {$d$};
				\path[->]
				(q0) edge node {$1$} (q1)
				(q1) edge node {$0$} (q2)
				(q2) edge node {$1$} (q3)
				(q3) edge node {$1$} (q4)
				(q4) edge node {$0$} (q5)
				(q5) edge [loop above] node {$0,1$} (q5)
				(q0) edge [bend right] node {$0$} (d)
				(q1) edge [loop above] node {$1$} (q1)
				(d) edge [loop below] node {$0$} (d);
				\end{tikzpicture} 
				\newline
				\flushleft{step 4: Add other edges,成为最终的$DFA$}
				\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
				\node[state,initial](q0) {$q_0$};
				\node[state,accepting](q1) [right of=q0] {$q_1$};
				\node[state,accepting](q2) [right of=q1] {$q_2$};
				\node[state,accepting](q3) [right of=q2] {$q_3$};
				\node[state,accepting](q4) [right of=q3] {$q_4$};
				\node[state](q5) [right of=q4] {$q_5$};
				\node[state,accepting](d) [below of=q1] {$d$};
				\path[->]
				(q0) edge node {$1$} (q1)
				(q1) edge node {$0$} (q2)
				(q2) edge node {$1$} (q3)
				(q3) edge node {$1$} (q4)
				(q4) edge node {$0$} (q5)
				(q5) edge [loop above] node {$0,1$} (q5)
				(q0) edge [bend right] node {$0$} (d)
				(q1) edge [loop above] node {$1$} (q1)
				(d) edge [loop below] node {$0$} (d)
				(d) edge node {$1$} (q1)
				(q2) edge node {$0$} (d)
				(q3) edge [bend left] node {$0$} (q2)
				(q4) edge [bend right,swap] node {$1$} (q1);
				\end{tikzpicture} 
				\caption{$\{x|x\in\{0,1\}^+\text{并且$x$中不含形如$10110$的子串}\}$语言的$NFA$}
				\label{fig:Not10110}
			\end{figure}
		\end{enumerate}
		
		\item 构造$\{x|x\in\{0,1\}^+\text{$x$以0开头以1结尾}\}$, $DFA$见图(\ref{fig:01})。$NFA$见图(\ref{fig:01NFA})。
		\begin{figure}[htbp]
			\centering
			\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
			\node[state,initial](q0) {$q_0$};
			\node[state](q1) [right of=q0] {$q_1$};
			\node[state,accepting](q2) [right of=q1] {$q_2$};
			\path[->]
			(q1) edge [loop above] node {$0,1$} (q1)
			(q0) edge node {$0$} (q1)
			(q1) edge node {$1$} (q2);
			\end{tikzpicture}
			\caption{$\{x|x\in\{0,1\}^+\text{$x$以0开头以1结尾}\}$语言的$NFA$}
			\label{fig:01NFA}
		\end{figure} 
	
		\item $\{x|x\in\{0,1\}^\ast\text{且如果$x$以1结尾,则它的长度为偶数;如果$x$以0结尾,则长度为奇数}\}$。\\
		$DFA$见图(\ref{fig:odd_even})。$NFA$见图(\ref{fig:odd_evenNFA})。
		\begin{figure}[htbp]
			\centering
			\flushleft{(1) $\epsilon\in L(M)$}
			\newline
			\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
			\node[state,accepting,initial](q0) {$q_0$};
			\node[state](q1) [right of=q0] {$q_1$};
			\node[state](q2) [right of=q1] {$q_2$};
			\node[state,accepting](q3) [right of=q2] {$q_3$};
			\node[state,accepting](q4) [below of=q0] {$q_4$};
			\node[state,accepting](q5) [below of=q1] {$q_5$};
			\path[->]
			(q2) edge [bend left] node {$0,1$} (q1)
			(q0) edge node {$0,1$} (q1)
			(q1) edge node {$0,1$} (q2)
			(q2) edge node {$0$} (q3)
			(q0) edge node {$0$} (q4)
			(q1) edge node {$1$} (q5);
			\end{tikzpicture}
			\newline
			\flushleft{(2) $\epsilon\notin L(M)$}
			\newline
			\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
			\node[state,initial](q0) {$q_0$};
			\node[state](q1) [right of=q0] {$q_1$};
			\node[state,accepting](q2) [right of=q1] {$q_2$};
			\node[state,accepting](q3) [below of=q0] {$q_3$};
			\path[->]
			(q1) edge [bend left] node {$0,1$} (q0)
			(q0) edge node {$0,1$} (q1)
			(q1) edge node {$1$} (q2)
			(q0) edge node {$0$} (q3);
			\end{tikzpicture}
			\caption{$\{x|x\in\{0,1\}^\ast\text{且如果$x$以1结尾,则它的长度为偶数;如果$x$以0结尾,则长度为奇数}\}$语言的$NFA$}
			\label{fig:odd_evenNFA}
		\end{figure} 
	
	\item 构造$\{x|x\in\{0,1\}^+\text{$x$首字符和尾字符形同}\}$语言的$NFA$见图(\ref{fig:se})。
		\begin{figure}[htbp]
			\centering
			\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.75in, on grid, auto]
			\node[state,initial](q0) {$q_0$};
			\node[state](q1) [right of=q0] {$q_1$};
			\node[state,accepting](q2) [right of=q1] {$q_2$};
			\node[state](q3) [below of=q1] {$q_3$};
			\node[state,accepting](q4) [right of=q3] {$q_4$};
			\node[state,accepting](q5) [below of=q0] {$q_5$};
			\path[->]
			(q1) edge [loop above] node {$0,1$} (q1)
			(q0) edge node {$1$} (q1)
			(q1) edge node {$1$} (q2)
			(q0) edge node {$0$} (q3)
			(q3) edge node {$0$} (q4)
			(q0) edge [swap] node {$0,1$} (q5)
			(q3) edge [loop below] node {$0,1$} (q3);
			\end{tikzpicture}
			\caption{$\{x|x\in\{0,1\}^+\text{$x$首字符和尾字符形同}\}$语言的$NFA$}
			\label{fig:se}
		\end{figure} 
	\end{enumerate}
\end{solution}		

\begin{exercise}
	证明：对于任意的$NFA$，存在与之等价的$NFA$，该$NFA$最多只有一个终止状态。
\end{exercise}

\begin{solution}
	证明提示：
	
	一般的，$NFA$会有多个状态，当该$NFA$的可达的终止状态数小于等于1时，删除所有的不可达状态即可；否则，先删除所有不可达状态，再构造与之等价的只有一个终止状态的$NFA$。
	
	最简单的办法是对不含不可达状态的$NFA$，将原来的终止状态均改为非终止状态，然后增加一个终止状态，并将原来存在的到达原来终止状态弧进行复制，使之也可以到达新的终止状态。
\end{solution}

\begin{exercise}构造识别下列语言的$\epsilon-NFA$:
	
	$\{x|x\in\{0,1\}^+\text{且$x$中不含形如$00$的子串}\}\cap\{x|x\in\{0,1\}^+\text{且$x$中不含形如$11$的子串}\}$
\end{exercise}

\begin{solution}
	分步构造，如图(\ref{fig:cap})。
	\begin{figure}[htbp]
		\centering
		\flushleft{step 1: 构造$\{x|x\in\{0,1\}^+ \text{且$x$中不含形如$00$的子串}\}$语言的$DFA$。} 
		构造要点是，自动机启动并读入一个字符后，就将"精力"集中在考察是否出现$00$子串上，一旦发现子串$00$，就进入陷阱状态。
		\newline
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.7in, on grid, auto]
		\node[state,initial] (q0) {$q_0$};
		\node[state,accepting](q1) [above right=of q0] {$q_1$};
		\node[state,accepting] (q2) [below=of q1] {$q_2$};
		\node[state](dump) [right=of q2] {$d$};
		\path[->]
		(q0) edge node {$1$} (q1)
		(q0) edge node {$0$} (q2)
		(q1) edge [loop above] node {$1$} (q1)
		(q1) edge [swap] node {$0$} (q2)
		(q2) edge [bend right,swap] node {$1$} (q1)
		(q2) edge node {$0$} (dump)
		(dump) edge [loop above] node {0,1} (dump) ;
		\end{tikzpicture}
		%\newline
		\flushleft{step 2: 构造$\{x|x\in\{0,1\}^+ \text{且$x$中不含形如$11$的子串}\}$语言的$DFA$。} 
		构造要点是，自动机启动并读入一个字符后，就将"精力"集中在考察是否出现$11$子串上，一旦发现子串$11$，就进入陷阱状态。
		\newline
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.7in, on grid, auto]
		\node[state,initial] (q0) {$q_0$};
		\node[state,accepting](q1) [above right=of q0] {$q_1$};
		\node[state,accepting] (q2) [below=of q1] {$q_2$};
		\node[state](dump) [right=of q2] {$d$};
		\path[->]
		(q0) edge node {$0$} (q1)
		(q0) edge node {$1$} (q2)
		(q1) edge [loop above] node {$0$} (q1)
		(q1) edge [swap] node {$1$} (q2)
		(q2) edge [bend right,swap] node {$0$} (q1)
		(q2) edge node {$1$} (dump)
		(dump) edge [loop above] node {0,1} (dump) ;
		\end{tikzpicture}	
		%\newline
		\flushleft{step 3: 构造$DFA_1\cap DFA_2$, 其中step 1 DFA = $DFA_1$, step 2 DFA = $DFA_2$。\\ \qquad state: $\forall (p,q)| p\in DFA_1,q\in DFA_2$; marked state: $p\in F_1$ and $q\in F_2$} 
		\newline	
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.7in, on grid, auto]
		\node[state,initial] (q0) {$q_0,q_0$};
		\node[state,accepting](q1) [above right=of q0] {$q_1,q_2$};
	    \node[state,accepting](q2) [below right=of q0] {$q_2,q_1$};
	    \node[state](q3) [right=of q1] {$q_1,d$};
	    \node[state](q4) [right=of q2] {$d,q_1$};
	    \node[state](q5) [right=of q3] {$q_2,d$};
	    \node[state](q6) [right=of q4] {$d,q_2$};
	    \node[state](q7) [above right=of q6] {$d,d$};
		\path[->]
		(q0) edge node {$1$} (q1)
		(q0) edge [swap] node {$0$} (q2)
		(q1) edge [swap] node {$0$} (q2)
		(q1) edge node {$1$} (q3)
		(q2) edge node {$0$} (q4)
		(q2) edge [bend right,swap] node {$1$} (q1)
		(q3) edge node {$0$} (q5)
		(q3) edge [loop above] node {$1$} (q3)
		(q4) edge node {$1$} (q6)
		(q4) edge [loop below] node {$0$} (q4)
		(q5) edge [bend left] node {$1$} (q3)
		(q5) edge node {$0$} (q7)
		(q6) edge [bend left] node {$0$} (q4)
		(q6) edge node {$1$} (q7)
		(q7) edge [loop right] node {$0,1$} (q7)
		;
		\end{tikzpicture}
		%\newline
		\flushleft{step 4: 归约(reduce) $DFA_1\cap DFA_2$} 
		\newline	
		\begin{tikzpicture}[>=latex, shorten >=1pt,node distance=0.7in, on grid, auto]
		\node[state,initial] (q0) {$q_0,q_0$};
		\node[state,accepting](q1) [above right=of q0] {$q_1,q_2$};
		\node[state,accepting](q2) [below right=of q0] {$q_2,q_1$};
		\node[state](dump) [right=of q2] {$dump$};
		\path[->]
		(q0) edge node {$1$} (q1)
		(q0) edge [swap] node {$0$} (q2)
		(q1) edge [swap] node {$0$} (q2)
		(q2) edge [bend right,swap] node {$1$} (q1)
		(q1) edge [bend left] node {$1$} (dump)
		(q2) edge node {$0$} (dump)
		(dump) edge [loop right] node {$0,1$} (dump)
		;
		\end{tikzpicture}			
		\caption{$\{x|x\in\{0,1\}^+\text{且$x$中不含形如$00$的子串}\}\cap\{x|x\in\{0,1\}^+\text{且$x$中不含形如$11$的子串}\}$语言的$\epsilon-NFA$}
		\label{fig:cap}	
	\end{figure}
\end{solution}

\begin{exercise}
	证明: 对于任意的$FA$ $M_1=(Q_1,\Sigma_1,\delta_1,q_{01},F_1)$, $FA$ $M_1=(Q_1,\Sigma_2,\delta_1,q_{02},F_1)$, 存在$FA$ $M$，使得$L(M)=L(M_1)\cup L(M_2)$。
\end{exercise}

\begin{solution}
	构造新的$FA$ $M=(Q,\Sigma,\delta,q_{0},F)$。
	\begin{enumerate}
		\item 新$FA$的输入字母表是原来两个字母表的并。$\Sigma = \Sigma_1\cup\Sigma_2$。
		\item 保留原来两个$FA$的所有状态，并增加一个新的开始状态$q_0$。$Q=Q_1\cup Q_2\cup \{q_0\},q_0\notin Q_1,Q_2$。
		\item 从新的开始状态$q_0$做$\epsilon$移动，分别到达原来两个$FA$的启动状态: $\delta(q_0,\epsilon) = \{q_{01},q_{02}\}$。
		\item 保留原来两个$FA$的所有移动。即$\delta = \delta_1\cup\delta_2\cup\{q_0\times\{q_{01},q_{02}\}\}$。
		\item 新的$FA$的终止状态是原来两个$FA$的并。$F=F_1\cup F_2$。
	\end{enumerate}
\end{solution}

\begin{exercise}
	证明: 对于任意的$FA$ $M_1=(Q_1,\Sigma_1,\delta_1,q_{01},F_1)$, $FA$ $M_1=(Q_1,\Sigma_2,\delta_1,q_{02},F_1)$, 存在$FA$ $M$，使得$L(M)=L(M_1)L(M_2)$。
\end{exercise}

\begin{solution}
	构造新的$FA$ $M=(Q,\Sigma,\delta,q_{0},F)$。
	\begin{enumerate}
		\item 新$FA$的输入字母表是原来两个字母表的并。$\Sigma = \Sigma_1\cup\Sigma_2$。
		\item 保留原来两个$FA$的所有状态。$Q=Q_1\cup Q_2\cup \{q_0\}$。
		\item $M_1$的开始状态为新的$FA$ $M$的启动状态。$q=q_{01}$。
		\item 保留原来两个$FA$的所有移动。并对$M_1$的所有终止状态$f$，增加一个到$M_2$的开始状态$q_{02}$的$\epsilon$移动：$\delta = \delta_1\cup\delta_2\cup\{f\times\{q_{02}\}\}$, $\delta(f,\epsilon)=q_{02},f\in F_1$。
		\item 新的$FA$的终止状态是原来两个$FA$ $M_2$的终止状态。$F=F_1$。
	\end{enumerate}
\end{solution}

\begin{exercise}
	证明: 对于任意的$FA$ $M_1=(Q_1,\Sigma_1,\delta_1,q_{01},F_1)$, $FA$ $M_1=(Q_1,\Sigma_2,\delta_1,q_{02},F_1)$, 存在$FA$ $M$，使得$L(M)=L(M_1)\cap L(M_2)$。
\end{exercise}

\begin{solution}
	不妨将这些$FA$均看成$DFA$\\
	取$DFA$ $M=(Q_1\times Q_2,\Sigma_1\cap\Sigma_2,\delta,[q_{01},q_{02},F_1\times F_2)$。\\
	$\forall a\in\Sigma_1\cap\Sigma_2,(q,p)\in Q_1\times Q_2$,\\
	$\delta([q,p],a)=[\delta_1(q,a),\delta_2(q,a)]$
\end{solution}

%\input{referenc}


